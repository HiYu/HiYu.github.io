<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡 若</title>
  
  <subtitle>初心 读书 知新 生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m.fanruo.net/"/>
  <updated>2020-02-22T15:11:16.682Z</updated>
  <id>https://m.fanruo.net/</id>
  
  <author>
    <name>Frank Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【leetcode】9. 数组-二维数组中的查找</title>
    <link href="https://m.fanruo.net/2020/02/22/%E3%80%90leetcode%E3%80%919-%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://m.fanruo.net/2020/02/22/【leetcode】9-数组-二维数组中的查找/</id>
    <published>2020-02-22T15:10:42.000Z</published>
    <updated>2020-02-22T15:11:16.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><blockquote><p>现有矩阵 matrix 如下：<br>[<br> [1,   4,  7, 11, 15],<br> [2,   5,  8, 12, 19],<br> [3,   6,  9, 16, 22],<br> [10, 13, 14, 17, 24],<br> [18, 21, 23, 26, 30]<br>]</p></blockquote><blockquote><p>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题抓住两个点：</p><ol><li>每一行都按照从左到右递增的顺序排序</li><li>每一列都按照从上到下递增的顺序排序</li></ol><p>以上两点说明：</p><ol><li>矩阵<code>matrix</code>中小于<code>matrix[i][j]</code>的元素只能出现在该元素所在列的左侧或者上侧，即列坐标小于<code>j</code>或者行坐标小于<code>i</code></li><li>矩阵<code>matrix</code>中大于<code>matrix[i][j]</code>的元素只能出现在该元素所在列的右侧或者下侧，即列坐标大于<code>j</code>或者行坐标大于<code>i</code></li></ol><p>我们从右上角开始遍历：</p><ol><li><code>matrix[i][j] == target</code>,返回 true</li><li><code>matrix[i][j] &gt; target</code>, 由<strong>说明1</strong>可知<code>target</code>只可能出现在左侧（<code>matrix[i][j]</code>右&amp;上侧的数据已经遍历过了），则<code>i++</code></li><li><code>matrix[i][j] &lt; target</code>, 由<strong>说明2</strong>可知<code>target</code>只可能出现在下侧（<code>matrix[i][j]</code>右&amp;上侧的数据已经遍历过了），则<code>j--</code></li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】8. 数组-数组中重复的数字</title>
    <link href="https://m.fanruo.net/2020/02/22/%E3%80%90leetcode%E3%80%918-%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/02/22/【leetcode】8-数组-数组中重复的数字/</id>
    <published>2020-02-22T15:09:39.000Z</published>
    <updated>2020-02-22T15:10:22.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>2 &lt;= n &lt;= 100000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题解法很多。注意两点：</p><ol><li>查找：想到随机查找（数组下标、关联容器key）</li><li>所有数字都在 0～n-1 的范围内：可以利用数据下标</li><li>找出数组中任意一个重复的数字</li></ol><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以再遍历数组的同时对每一个元素做一个标记，这个标记是可以在O(1)时间复杂度获取的，继续遍历数组，并判断元素标记，如果已经存在，则直接返回，否则改变标志。具体流程如下：</p><ol><li>创建一个<code>map&lt;int, bool&gt; ret</code></li><li>遍历数组<code>nums</code>,如果<code>ret[nums[i]]</code> 不存在，则<code>ret[nums[i]] = true</code>；如果<code>ret[nums[i]] = true</code>，则返回<code>nums[i]</code></li></ol><p><strong>tips</strong>：步骤1种使用<code>map</code>并不是最优的,也可以使用<code>set</code>。在数组元素重复的比较少的时候可以使用<code>vector</code>。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; ret;<span class="comment">// 使用map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret.count(nums[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                ret[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret(nums.size(), <span class="literal">false</span>);<span class="comment">// 使用vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret[nums[i]] == <span class="literal">false</span>) &#123;</span><br><span class="line">                ret[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ret;<span class="comment">// 使用set</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ret.insert(nums[i]).second) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题并没限制不能改变原有数组<code>nums</code>，同时强调，所有数字都在 0～n-1 的范围内。因此，可以将元素<code>nums[i]</code>移动到<code>nums[nums[i]]</code>：</p><ol><li>当<code>nums[i] == i</code>,说明<code>i</code>位置上的元素已经是<code>i</code>了，不做任何处理，继续遍历</li><li>当<code>nums[i] == nums[nums[i]]</code>，说明<code>nums[i]</code>位置的元素已经是<code>nums[i]</code>,说明重复了，返回<code>nums[i]</code>即可</li><li>当上述两个条件都不满足的时候，交换一下</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i ) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[nums[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                nums[tmp] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;找出数组中重复的数字。&lt;br&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【好书推荐】血疫-埃博拉的故事</title>
    <link href="https://m.fanruo.net/2020/02/21/%E3%80%90%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90%E3%80%91%E8%A1%80%E7%96%AB-%E5%9F%83%E5%8D%9A%E6%8B%89%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>https://m.fanruo.net/2020/02/21/【好书推荐】血疫-埃博拉的故事/</id>
    <published>2020-02-21T02:02:31.000Z</published>
    <updated>2020-02-24T01:44:41.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/%E8%A1%80%E7%96%AB.png" alt="image"><br>这是一本“人命关天”的书。<br>艾滋病、SARS、埃博拉、寨卡，文明与病毒之间，只隔了一个航班的距离。<br>来自热带雨林的危险病毒，可在24小时内乘飞机抵达地球上的任何城市。航空线路连接了全世界的所有城市，构成网络。埃博拉已经进入网络，开始环球旅行。<br>这不只是一个病毒的故事，它关系着人类的无知、贪婪、勇气和牺牲，以及面对大自然时的敬畏。<br>真实，远比想象更惊悚。</p><p>普雷斯顿采访1967-1993年间大量埃博拉病毒亲历者，再现人类历史上病毒灾难来袭的真实场景。<br>1989年11月，美国弗吉尼亚州的雷斯顿城发生过埃博拉病毒事件。这个小城位于华盛顿特区以西24公里处，晴朗的天气里人们都能在雷斯顿城的高层建筑上望见华盛顿纪念碑那米黄色的尖顶。这里的灵长类动物检疫中心接收了100只从菲律宾进口的食蟹猴。没过几天，两只死亡。<br>理论上，少量动物死亡是很常见的。令人不安的是，不到一个月，又有29只猴子死亡。随着猴子死亡相继增加，科研人员渐渐逼近真相：猴子感染了一种未知的病毒。在大量研究下，他们认为这是埃博拉病毒。最后，美军出动将大楼封锁，所有动物处死。幸运的是，在目前已知的五种埃博拉病毒中，这种雷斯顿型亚型只感染灵长类动物，让人类逃过一劫。<br>1994年，美国作家理查德.普雷斯顿基于这一史料，采访大量亲历者后出版非虚构作品。</p><h1 id="总结-amp-拓展"><a href="#总结-amp-拓展" class="headerlink" title="总结&amp;拓展"></a>总结&amp;拓展</h1><p>全书介绍了<code>丝状病毒</code>的几种比较早期的病毒发现爆发的过程。<code>丝状病毒</code>包含的属有：</p><ol><li>马尔堡病毒</li><li>埃博拉病毒</li></ol><p>其中埃博拉病毒包括：</p><ol><li>Zaire ebolavirus（EBOV） (扎伊尔埃博拉病毒, 1976）- 标准亚种 （致死率高达90%）</li><li>Sudan ebolavirus（SUDV） (苏丹埃博拉病毒, 1976） （致死率高达68%）</li><li>Reston ebolavirus（RESTV） (雷斯顿埃博拉病毒, 1989）（所有感染者都为猴类，无人类感染）</li><li>Taï Forest ebolavirus（TAFV） (科特迪瓦埃博拉病毒, 1994）</li><li>Bundibugyo ebolavirus（BDBV） (本迪布焦埃博拉病毒, 2007）</li><li>Bombali ebolavirus（BOMV） (邦巴利埃博拉病毒, 2018）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://q66nxrlmf.bkt.clouddn.com/%E8%A1%80%E7%96%AB.png&quot; alt
      
    
    </summary>
    
      <category term="书籍推荐" scheme="https://m.fanruo.net/categories/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="埃博拉" scheme="https://m.fanruo.net/tags/%E5%9F%83%E5%8D%9A%E6%8B%89/"/>
    
      <category term="丝状病毒" scheme="https://m.fanruo.net/tags/%E4%B8%9D%E7%8A%B6%E7%97%85%E6%AF%92/"/>
    
      <category term="马尔堡" scheme="https://m.fanruo.net/tags/%E9%A9%AC%E5%B0%94%E5%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】7. 数组-移除元素</title>
    <link href="https://m.fanruo.net/2020/02/19/%E3%80%90leetcode%E3%80%917-%E6%95%B0%E7%BB%84-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>https://m.fanruo.net/2020/02/19/【leetcode】7-数组-移除元素/</id>
    <published>2020-02-19T15:59:06.000Z</published>
    <updated>2020-02-21T05:59:54.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1</strong>:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 2</strong>:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。<br>本题依旧是双指针问题，下标<code>l</code>是新数组的尾后位置，遍历数组<code>nums</code>，当元素<code>nums[i]!=val</code>时，将<code>nums[i]</code>追加到新数组尾部。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nums.size(); r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] != val) &#123;</span><br><span class="line">                nums[l++] = nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>注意，方法一中，虽然时间复杂度是O(N)，但是，当需要删除的数据很少的时候，会做很多不必要的复制赋值操作，假设数组总共有<code>n</code>个元素，和 <code>l</code>,<code>i</code>至少遍历<code>2n</code>步。例如数组<code>nums[] = [1,2,3,4,5]; val = 5</code>，遍历过程种会执行<code>nums[0] = nums[0], ... nums[3] = nums[3]</code>等一系列不必要的操作。</p><p>我们注意到题目中提到<code>元素的顺序可以改变</code>,这是在提示我们，除了<code>解法一</code>还有其他方法，而且元素的顺序是改变了的：<br>当遇到<code>nums[l] = val</code>时，可以将当前元素与最后一个元素<code>nums[r]</code>进行交换，并释放最后一个元素。这实际上使数组的大小减少了1。<br>请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[l] == val) &#123;</span><br><span class="line">               nums[l] = nums[r];<span class="comment">//这里nums[r]的值已经存放在nums[r]，原nums[l]数据本来就是要删除的，因此不需要完全交换两个元素</span></span><br><span class="line">               r--;<span class="comment">//只移动r，不移动l，因为nums[r]可能也等于val，导致交换后，nums[l]==val</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】6. 数组-删除排序数组中的重复项</title>
    <link href="https://m.fanruo.net/2020/02/19/%E3%80%90leetcode%E3%80%916-%E6%95%B0%E7%BB%84-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://m.fanruo.net/2020/02/19/【leetcode】6-数组-删除排序数组中的重复项/</id>
    <published>2020-02-19T15:14:08.000Z</published>
    <updated>2020-02-19T16:10:39.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你<strong>必须在原地修改输入数组并在使用 O(1)额外空间的条件</strong>下完成。</p><p><strong>示例 1</strong>:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 2</strong>:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p><p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要注意几个点：</p><ol><li>数组是有序的</li><li>删除数组中重复的元素，每个元素只保留一个</li><li>原地删除，即在传入数组的基础上删除</li><li>空间复杂度为<code>O(1)</code></li></ol><p>依据上述要求，只能操作原数组<code>nums</code>，解题思路：遍历数组，将非重复的元素前移覆盖重复元素（从重复元素的第二个开始倍覆盖）。具体算法是：</p><ol><li>设两个游标<code>k</code>和<code>i</code>,<code>k</code>为最先可以被覆盖元素的下标,<code>i</code>为数组遍历游标</li><li><code>k</code>的初始值为<code>1</code>:删除数组中重复的元素，每个元素只保留一个，因此从第二个元素开始删，即k之前的子数组各元素已经是唯一的</li><li><code>i</code>的初始值也为<code>1</code>,遍历时比较<code>nums[i]</code>是否和<code>nums[i-1]</code>,如果，如果不相等则将其移动到<code>k</code>处，并且<code>k++</code></li><li>由于<code>k</code>是最后一个可以覆盖的位置，因此<code>k</code>即新数组长度</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i<span class="number">-1</span>] != nums[i]) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你&lt;str
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】5. 数组-两数之和</title>
    <link href="https://m.fanruo.net/2020/02/19/%E3%80%90leetcode%E3%80%915-%E6%95%B0%E7%BB%84-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://m.fanruo.net/2020/02/19/【leetcode】5-数组-两数之和/</id>
    <published>2020-02-19T13:28:19.000Z</published>
    <updated>2020-02-19T13:36:33.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题比较简单，可以简单转换一下，有元素<code>nums[i]</code>， 数组<code>nums</code>是否存在<code>target - nums[i]</code>，即转换成一个查找问题：</p><ol><li>如果原地查找，不开辟额外空间的话，查找一个元素最好的情况是<code>O(log(n))</code>，这还是数组有序的情况下，显然本题数组不是有序；</li><li>可以定义一个map，查找时间复杂度是<code>O(1)</code>。<br>因此，本题，可以这么做：</li><li>遍历数组<code>nums</code>,创建map，<code>diff[nums[i]] = i</code></li><li>再次遍历<code>nums</code>,检查<code>diff[target-nums[i]]</code>是否存在，如果存在即满足需求</li></ol><p>注意，上述方法需要遍历两次数组<code>nums</code>，其实，可以只遍历一次，边遍历边检查。代码如下<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (diff.count(sub) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret.push_back(diff[sub]);</span><br><span class="line">                ret.push_back(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                diff[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;br&gt;你可以假设每
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>推荐几本redis书籍</title>
    <link href="https://m.fanruo.net/2020/02/18/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%9C%ACredis%E4%B9%A6%E7%B1%8D/"/>
    <id>https://m.fanruo.net/2020/02/18/推荐几本redis书籍/</id>
    <published>2020-02-18T05:58:50.000Z</published>
    <updated>2020-02-24T01:46:55.992Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为基于键值对的NoSQL数据库，具有高性能、丰富的数据结构、持久化、高可用、分布式等特性，同时Redis本身非常稳定，已经得到业界的广泛认可和使用。 掌握Redis已经逐步成为开发和运维人员的必备技能之一。下面分享一下几本本人看过的Redis书籍，希望对大家有所帮助。</p><h1 id="Redis开发与运维"><a href="#Redis开发与运维" class="headerlink" title="Redis开发与运维"></a>Redis开发与运维</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4.png" alt="image"><br>本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。</p><h1 id="Redis-深度历险：核心原理与应用实践"><a href="#Redis-深度历险：核心原理与应用实践" class="headerlink" title="Redis 深度历险：核心原理与应用实践"></a>Redis 深度历险：核心原理与应用实践</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9.png" alt="image"><br>Redis 是互联网技术架构在存储系统中使用得最为广泛的中间件，也是中高级后端工程师技术面试中面试官最喜欢问的工程技能之一，特别是那些优秀的互联网公司，通常要求面试者不仅仅掌握 Redis 基础用法，还要理解 Redis 内部实现的细节原理。《Redis 深度历险：核心原理与应用实践》作者老钱在使用 Redis 上积累了丰富的实战经验，希望帮助更多后端开发者更快、更深入地掌握 Redis 技能。</p><p>《Redis 深度历险：核心原理与应用实践》分为基础和应用篇、原理篇、集群篇、拓展篇、源码篇共 5 大块内容。基础和应用篇讲解对读者来说最有价值的内容，可以直接应用到实际工作中；原理篇、集群篇让开发者透过简单的技术表面看到精致的底层世界；拓展篇帮助读者拓展技术视野和夯实基础，便于进阶学习；源码篇让高阶的读者能够读懂源码，掌握核心技术实力。</p><h1 id="Redis设计与实现"><a href="#Redis设计与实现" class="headerlink" title="Redis设计与实现"></a>Redis设计与实现</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.png" alt="image"><br>本书全面而完整地讲解了Redis的内部机制与实现方式，对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想,图示丰富，描述清晰，并给出大量参考信息。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，更好、更高效地使用Redis。</p><p>本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制、集群三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。本书作者专门维护了 <a href="http://www.redisbook.com" target="_blank" rel="noopener">www.redisbook.com</a> 网站，提供带有详细注释的Redis源代码，以及本书相关的更新内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>三本书都是国人原创，豆瓣上都在8.5分以上，比较良心了。《Redis开发与运维》原理与实践并重的同时，更多的分析了实际生产环境中踩过的各种坑，比较接地气，毕竟大多数人只是使用而非对Redis做二次开发。《Redis设计与实现》比较详尽的介绍了Redis的实现，对有希望了解Redis底层的同学会有比较大的帮助。《Redis 深度历险：核心原理与应用实践》文风亲切，从客户端的视角去看Reids，同时对最新版本的一些关键特性做了介绍，但受限于篇幅，并没有特别深入。总之，这三本书写的通俗易懂，结合来看能够既懂原理，又能了解实践，同时对新特性也能有所收获。</p><p>好书很多，不过没看过没有发言权，不敢随意推荐。<br>saiya_dp_rus_md5_resource_l_64b78d992acd68a4501640fd50ba30c0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis作为基于键值对的NoSQL数据库，具有高性能、丰富的数据结构、持久化、高可用、分布式等特性，同时Redis本身非常稳定，已经得到业界的广泛认可和使用。 掌握Redis已经逐步成为开发和运维人员的必备技能之一。下面分享一下几本本人看过的Redis书籍，希望对大家有所
      
    
    </summary>
    
      <category term="Redis" scheme="https://m.fanruo.net/categories/Redis/"/>
    
      <category term="书籍推荐" scheme="https://m.fanruo.net/categories/Redis/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="Redis" scheme="https://m.fanruo.net/tags/Redis/"/>
    
      <category term="书籍推荐" scheme="https://m.fanruo.net/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】4. 数组-对角线遍历</title>
    <link href="https://m.fanruo.net/2020/02/18/%E3%80%90leetcode%E3%80%914-%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/"/>
    <id>https://m.fanruo.net/2020/02/18/【leetcode】4-数组-对角线遍历/</id>
    <published>2020-02-17T17:38:20.000Z</published>
    <updated>2020-02-18T00:12:23.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。<br>难易程度：<em>Medium</em></p><p><strong>示例</strong>:</p><p><strong>输入</strong>:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]</p><p><strong>输出</strong>:  [1,2,4,7,5,3,6,8,9]</p><p><strong>解释</strong>:<br><img src="/2020/02/18/【leetcode】4-数组-对角线遍历/diagonal_traverse.png" alt="image"></p><p><strong>说明</strong>:<br>给定矩阵中的元素总数不会超过 100000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要仔细揣摩题目，找出规律。抓住两点：</p><ol><li>题目实例，如果给出的<code>3*3</code>的矩阵不能有所收获的话，可以尝试更其他组合的矩阵，比如<code>4*3</code>等等。</li><li>题图，图的表现力更强一些，同样，如果题目种的图不能发现规律的话，可以尝试更多的矩阵。<br>经过一通分析，发现如下规律[为表述方便设某一元素的坐标为<code>(x,y)</code>]：</li><li><code>x + y</code> 为偶数是遍历方向为：<code>左下-&gt;右上，x--，y++</code>，<code>x + y</code> 为奇数是遍历方向为：<code>右上-&gt;左下,y--, x++</code></li><li>一共遍历<code>M + N - 1</code> 次，即遍历<code>[0, M+N-2]</code></li><li>第n次遍历是<code>n = x + y</code>，<code>n</code>从0开始</li><li>每次遍历的时候，<code>左下-&gt;右上</code> 若<code>x &lt; M</code>则起点为<code>(n, 0)</code>否则为<code>(M-1,n-M-1)</code>;<code>右上-&gt;左下</code>若<code>y &lt; N</code>则起点为<code>(0, n)</code>否则为<code>(n-N-1, N-1)</code></li></ol><p>具体分析如下(以示例种3*3矩阵举例)：<br>第0趟 <code>x = 0, y = 0; x + y = 0</code>，0是偶数，<code>左下-&gt;右上</code>，<code>[(0,0)],[1]</code><br>第1趟 <code>x = 0, y = 1; x + y = 1</code>，1是奇数，<code>右上-&gt;左下</code>，<code>[(0,1),(1,0)],[2,4]</code><br>第2趟 <code>x = 2, y = 0; x + y = 2</code>，2是偶数，<code>左下-&gt;右上</code>，<code>[(2,0),(1,1),(0,2)],[7,5,3]</code><br>第3趟 <code>x = 1, y = 2; x + y = 3</code>，3是奇数，<code>右上-&gt;左下</code>，<code>[(1,2),(2,1)],[6,8]</code><br>第4趟 <code>x = 2, y = 2; x + y = 4</code>，4是偶数，<code>左下-&gt;右上</code>，<code>[(2,2)],[9]</code><br>因此，对角遍历后的结果为<code>[1,2,4,7,5,3,6,8,9]</code></p><p><strong>时间复杂度</strong>：O(N*N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDiagonalOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; m + n; t++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                x = t &lt; m ? t : m - <span class="number">1</span>;</span><br><span class="line">                y = t - x;</span><br><span class="line">                <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    ret.push_back(matrix[x][y]);</span><br><span class="line">                    x--;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y = t &lt; n ? t : n - <span class="number">1</span>;</span><br><span class="line">                x = t - y;</span><br><span class="line">                <span class="keyword">while</span> (y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m) &#123;</span><br><span class="line">                    ret.push_back(matrix[x][y]);</span><br><span class="line">                    y--;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。&lt;br&gt;难易程
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】3. 数组-加一</title>
    <link href="https://m.fanruo.net/2020/02/16/%E3%80%90leetcode%E3%80%91%E6%95%B0%E7%BB%84-%E5%8A%A0%E4%B8%80/"/>
    <id>https://m.fanruo.net/2020/02/16/【leetcode】数组-加一/</id>
    <published>2020-02-16T12:16:14.000Z</published>
    <updated>2020-02-18T00:08:53.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。<br><strong>难易程度</strong>：easy<br><strong>示例 1</strong>:<br>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p><p><strong>示例 2</strong>:<br>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>此题可以理解为模拟加法。因此本题需要考虑的一点是<strong>进位</strong>问题，尤其是要考虑最高位进位。<br>看完题目，最近直接想方法是十进制加法，从最低位位开始加一，设数组digits长度为n，则从digits[n-1]开始加1，当gigits[n-1]+1&gt;10,则产出进位1，逆序遍历数组digits每个元素加上上一个元素执行加法操作之后的进位c。至此，大家可能已经发现最初的被加数1，其实可以看作c=1。直接上代码。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;<span class="comment">// 加1，看作最初的进位</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(digits);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ret.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = ret[i] + c;</span><br><span class="line">            c = tmp / <span class="number">10</span>;</span><br><span class="line">            ret[i] = tmp % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125; <span class="comment">// 提前返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            ret.insert(ret.begin(), c);<span class="comment">// vector的非尾部插入极其耗时。</span></span><br><span class="line">        &#125;<span class="comment">// 处理最高位进位</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>解法一是很常规的解法，就是模拟加法。我们仔细研究题目，会发现本题有几个特点：</p><ol><li>只加1，意味着，只有在对应的元素digits[i]是9的时候才会产生进位1</li><li>产生进位之后digits[i]对应位上只能是0<br>综上，我们只需要逆序遍历数组digits（这是数组长度为n）,如果索引i对应的元素是9，则置0继续遍历，不是9的则加1，直接返回，当一致遍历到i=0,切digits[0] = 9,才会在最高位产生进位，注意，此时索引1~(n-1)位上都是0。因此只需要将digits[0]设置为1，并且在数组尾部新增一个元素0即可。（有同学应该已经发现，只有digits数组是类似[9,9,9]（即所以元素都是9的时候）才会产生溢出）.<br>相比解法一，少了取模和除法操作，也少了vector插入操作，耗时进一步优化。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        digits.push_back(<span class="number">0</span>);</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。&lt;br&gt;最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。&lt;br
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】数组-1. 至少是其他数字两倍的最大数</title>
    <link href="https://m.fanruo.net/2020/02/16/%E3%80%90leetcode%E3%80%91%E6%95%B0%E7%BB%84-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <id>https://m.fanruo.net/2020/02/16/【leetcode】数组-至少是其他数字两倍的最大数/</id>
    <published>2020-02-16T11:24:55.000Z</published>
    <updated>2020-02-18T00:10:12.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个给定的数组nums中，总是存在一个最大元素 。<br>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。<br>如果是，则返回最大元素的索引，否则返回-1。<br>难易程度：<em>easy</em><br><strong>示例 1</strong>:</p><p>输入: nums = [3, 6, 1, 0]<br>输出: 1<br>解释: 6是最大的整数, 对于数组中的其他整数,<br>6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1. </p><p><strong>示例 2</strong>:</p><p>输入: nums = [1, 2, 3, 4]<br>输出: -1<br>解释: 4没有超过3的两倍大, 所以我们返回 -1.</p><p><strong>提示</strong>:</p><p>nums 的长度范围在[1, 50].<br>每个 nums[i] 的整数范围在 [0, 100].</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题比较简单，只需遍历一遍数组，记录最大值max、最大值索引i以及次最大值，如果最大值大于次最大值的2倍即满足要求。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> second_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">                second_max = max;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; second_max) &#123;</span><br><span class="line">                second_max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &gt;= (second_max * <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在一个给定的数组nums中，总是存在一个最大元素 。&lt;br&gt;查找数组中的最大元素是否至少是数组中每个其他数字的两倍。&lt;br&gt;如果是，则返回最
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】数组-2. 寻找数组的中心索引</title>
    <link href="https://m.fanruo.net/2020/02/16/%E3%80%90leetcode%E3%80%91%E6%95%B0%E7%BB%84-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
    <id>https://m.fanruo.net/2020/02/16/【leetcode】数组-寻找数组的中心索引/</id>
    <published>2020-02-16T11:11:07.000Z</published>
    <updated>2020-02-18T00:09:28.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。<br>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。<br>难易程度：<em>easy</em><br><strong>示例 1:</strong></p><p>输入:<br>nums = [1, 7, 3, 6, 5, 6]<br>输出: 3<br>解释:<br>索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。<br>同时, 3 也是第一个符合要求的中心索引。</p><p><strong>示例 2:</strong></p><p>输入:<br>nums = [1, 2, 3]<br>输出: -1<br>解释:<br>数组中不存在满足此条件的中心索引。<br>说明:</p><p>nums 的长度范围为 [0, 10000]。<br>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>开辟一个新的数组prev_sum，数组大小为N+1（N为原始数组大小），遍历整个数组计算前i个元素之和存入prev_sum[i]中,注意prev_sum[0]=0。<br>则，原数组索引j，左侧元素之和为prev_sum[j], 右侧元素之和为prev_sum[N] - prev_sum[j + 1]。<br>循环比较prev_sum[j]是否与prev_sum[N] - prev_sum[j + 1]相等。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev_sum;</span><br><span class="line">        prev_sum.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>  (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            prev_sum.push_back(nums[i] + prev_sum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = prev_sum[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev_sum[i] == sum - prev_sum[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>解法一中，需要开辟一个新的数组,如何避免这部分空间的浪费呢？通过分析，我们可以知道，整个数组所有元素之和sum为索引i上的元素加上左右两侧子数组之和，按照中心索引的定义，中心索引i的左侧所有元素相加的和left_sum等于右侧所有元素相加的和right_sum，即left_sum * 2 = sum - nums[i]。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> size = nums.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">           sum += nums[i];</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">int</span> left_sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (left_sum * <span class="number">2</span> == sum - nums[i]) &#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">           left_sum += nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。&lt;br&gt;我们是这样定义数组中心索引的：数组中心索引的左侧所有元素
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>接入层 Nginx 部分 worker 进程死锁解决方案</title>
    <link href="https://m.fanruo.net/2019/06/28/%E6%8E%A5%E5%85%A5%E5%B1%82-nginx-%E9%83%A8%E5%88%86-worker-%E8%BF%9B%E7%A8%8B%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://m.fanruo.net/2019/06/28/接入层-nginx-部分-worker-进程死锁解决方案/</id>
    <published>2019-06-28T05:14:30.000Z</published>
    <updated>2020-02-17T17:37:54.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>部分 worker 进程 CPU 使用率达到100%整个 worker 不可用。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="诱因"><a href="#诱因" class="headerlink" title="诱因"></a>诱因</h3><p>上游长连接服务上线，由于服务发现服务生效时间长，导致 Nginx 连接上游失败，在释放连接时 Nginx worker 进程可能在持有读锁时出现问题，从而导致读写锁的状态和实际情况不一致，最终读锁永远没法释放，而写锁会死锁。</p><h3 id="主因"><a href="#主因" class="headerlink" title="主因"></a>主因</h3><p>通过火焰图分析，发现整个进程的耗时都在 ngx_rwlock_wlock 这个函数上。<br><img src="/2019/06/28/接入层-nginx-部分-worker-进程死锁解决方案/1_火焰图.png" alt=""></p><p>通 GDB 查看该进程的堆栈信息，执行下面的命令（121606 是对应 CPU 打满进程的进程号 ），查看进程调用栈。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 先执行下面命令进入 GDB</span><br><span class="line">/opt/compiler/gcc-4.8.2/bin/gdb -nx /proc/121606/exe 121606</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span> 执行 bt</span><br><span class="line"><span class="meta">&gt;</span> bt</span><br></pre></td></tr></table></figure></p><p>上述命令执行的结果如下图，可以看出 worker 进程在释放连接时出现问题，最终死锁在 ngx_rwlock_wlock 函数上。</p><p><img src="/2019/06/28/接入层-nginx-部分-worker-进程死锁解决方案/2_bt.png" alt=""></p><p>查看 Nginx 源码，可以发现在 ngx_http_upstream_free_round_robin_peer 函数中 调用了 ngx_http_upstream_rr_peers_rlock 函数，该函数最终调用了 ngx_rwlock_wlock。<br><img src="/2019/06/28/接入层-nginx-部分-worker-进程死锁解决方案/3_code.png" alt=""></p><p>从上面的代码可以看出当宏定义 NGX_HTTP_UPSTREAM_ZONE 为1时 ngx_http_upstream_rr_peer_lock 有可能加锁，当 NGX_HTTP_UPSTREAM_ZONE 不为1时，不会加锁。当 Nginx 编译时不将http_upstream_zone_module 模块去掉(添加 –without-http_upstream_zone_module 参数)时 NGX_HTTP_UPSTREAM_ZONE 为1，即使在 Nginx 中没有使用 zone 指令。<br><img src="/2019/06/28/接入层-nginx-部分-worker-进程死锁解决方案/4_code.png" alt=""></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>由于我们没有使用 zone 指令，即没有使用 http_upstream_zone_module 模块，只需重新编译 Nginx 二进制，将 http_upstream_zone_module 模块去掉(添加 –without-http_upstream_zone_module 参数)即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;部分 worker 进程 CPU 使用率达到100%整个 worker 不可用。&lt;/p&gt;
&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot;
      
    
    </summary>
    
      <category term="Nginx" scheme="https://m.fanruo.net/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://m.fanruo.net/tags/Nginx/"/>
    
      <category term="cpu" scheme="https://m.fanruo.net/tags/cpu/"/>
    
      <category term="负载" scheme="https://m.fanruo.net/tags/%E8%B4%9F%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>openresty 执行阶段问题踩坑</title>
    <link href="https://m.fanruo.net/2019/06/18/openresty-%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/"/>
    <id>https://m.fanruo.net/2019/06/18/openresty-执行阶段问题踩坑/</id>
    <published>2019-06-18T06:55:58.000Z</published>
    <updated>2019-06-18T06:56:59.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于业务需求我们需要根据<code>client_ip</code>对部分接口做一个简单的 ab test，将部分流量导新的服务上。基于之前做 WAF 的经验，制定了大体方案：根据 <code>client_ip</code> 做 hash， 根据 hash 值来确定是请求新后端还是原来的后端服务。<br>在说明详细方案前，先说明一下现状。当前的配置如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/api/rest/v\d+/Login &#123;</span><br><span class="line">    rewrite ^(.*)$ /loginServer$1 break;</span><br><span class="line"></span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header Clientip $http_clientip;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Scheme $scheme;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Connection "";</span><br><span class="line"></span><br><span class="line">    proxy_pass http://test.fanruo.net;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>/loginServer</code>是当前服务路径前缀，<code>/loginServerNew</code>是新服务路径前缀。所以，具体需求可以描述为，10% 的用户使用<code>/loginServerNew</code>服务，90% 的用户使用<code>/loginServer</code>服务。</p><h3 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h3><ol><li>根据字符串 client_ip 转成长整数 ip_num;</li><li>对 ip_num 按 100 取模，取最后两位 hash；</li><li>当 hash &lt; 10 时走<code>/loginServerNew</code>服务， 设置 <code>tag=&quot;New&quot;</code>, 否则 <code>tag=&quot;&quot;</code></li><li>改造<code>rewrite</code>指令为<code>rewrite ^(.*)$ /loginServer$tag$1 break;</code></li></ol><p>对应配置为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/api/rest/v\d+/Login &#123;</span><br><span class="line">    set $tag "";</span><br><span class="line">    access_by_lua_file conf/lua/abtest.lua;</span><br><span class="line">    rewrite ^(.*)$ /loginServer$tag$1 break;</span><br><span class="line"></span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header Clientip $http_clientip;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Scheme $scheme;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Connection "";</span><br><span class="line"></span><br><span class="line">    proxy_pass http://test.fanruo.net;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 lua 脚本（conf/lua/btest.lua）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> client_ip = ngx.var.http_clientip <span class="keyword">or</span> ngx.var.remote_addr</span><br><span class="line"><span class="keyword">local</span> o1,o2,o3,o4 = client_ip:<span class="built_in">match</span>(<span class="string">"(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)"</span> )</span><br><span class="line"><span class="keyword">local</span> ip_num = <span class="number">2</span>^<span class="number">24</span>*o1 + <span class="number">2</span>^<span class="number">16</span>*o2 + <span class="number">2</span>^<span class="number">8</span>*o3 + o4</span><br><span class="line"><span class="keyword">local</span> hash = ip_num % <span class="number">100</span></span><br><span class="line"></span><br><span class="line">ngx.var.tag = <span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> hash &gt; <span class="number">10</span> <span class="keyword">then</span></span><br><span class="line">    ngx.var.tag = <span class="string">"New"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>按照上述实现，最终总是走原来的服务<code>/loginServer</code>。通过分析 tag 的值一直是 “”，因此，需求不能满足。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>通过分析，由于之前 WAF 是通过直接修改 proxy_pass 参数来完成的，而 proxy_pass 对应 content phase，该阶段在 access phase 之后，因此上面的配置没有问题。而本需求是在 rewrite phase，因此需要在该阶段之前修改对应变量 tag 只能在 set phase 来完成 nginx 变量修改操作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>跟进上述分析，修改 nginx.conf 配置和 lua 脚本如下：</p><p>lua 脚本修改为：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> client_ip = ngx.var.http_clientip <span class="keyword">or</span> ngx.var.remote_addr</span><br><span class="line"><span class="keyword">local</span> o1,o2,o3,o4 = client_ip:<span class="built_in">match</span>(<span class="string">"(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)"</span> )</span><br><span class="line"><span class="keyword">local</span> ip_num = <span class="number">2</span>^<span class="number">24</span>*o1 + <span class="number">2</span>^<span class="number">16</span>*o2 + <span class="number">2</span>^<span class="number">8</span>*o3 + o4</span><br><span class="line"><span class="keyword">local</span> hash = ip_num % <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tag = <span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> hash &gt; <span class="number">10</span> <span class="keyword">then</span></span><br><span class="line">    tag = <span class="string">"New"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tag</span><br></pre></td></tr></table></figure></p><p>nginx.conf 配置修改为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/api/rest/v\d+/Login &#123;</span><br><span class="line">    set_by_lua_file $tag conf/lua/abtest.lua;</span><br><span class="line">    rewrite ^(.*)$ /loginServer$tag$1 break;</span><br><span class="line"></span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header Clientip $http_clientip;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Scheme $scheme;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Connection "";</span><br><span class="line"></span><br><span class="line">    proxy_pass http://test.fanruo.net;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;由于业务需求我们需要根据&lt;code&gt;client_ip&lt;/code&gt;对部分接口做一个简单的 ab test，将部分流量导新的服务上。基于之前
      
    
    </summary>
    
      <category term="OpenResty" scheme="https://m.fanruo.net/categories/OpenResty/"/>
    
    
      <category term="OpenResty" scheme="https://m.fanruo.net/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>nginx + lua 开发中过程中 post body 过大返回 4xx (续)</title>
    <link href="https://m.fanruo.net/2019/05/29/nginx-lua-%E5%BC%80%E5%8F%91%E4%B8%AD%E8%BF%87%E7%A8%8B%E4%B8%AD-post-body-%E8%BF%87%E5%A4%A7%E8%BF%94%E5%9B%9E-4xx-%E7%BB%AD/"/>
    <id>https://m.fanruo.net/2019/05/29/nginx-lua-开发中过程中-post-body-过大返回-4xx-续/</id>
    <published>2019-05-29T01:21:00.000Z</published>
    <updated>2019-05-29T01:33:09.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着业务发展会出现较大的 post body 数据，按照<a href="/2019/05/28/nginx-lua-开发中过程中-post-body-过大返回-4xx/" title="nginx + lua 开发中过程中 post body 过大返回 4xx">nginx + lua 开发中过程中 post body 过大返回 4xx</a>提到的方式修改后，大部分情况下 post body 正常接收并处理落日志。但会偶现空日志的情况。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>经过多轮本地和沙盒压测，复现了问题。由于在出现空日志情况是 error 日志并没留下相关信息，随后做了如下处理：</p><ol><li>把 error 日志级别调到 debug，当问题复现时，error.log 中会有客户端过早断开连接类似的日子打出。</li><li>在 access 日志中添加 request_time, status,等信息，发现出现空日志时，status=408，request_time 都比较长。</li></ol><p>因此，可以明确出现该问题是客户端链接超时造成的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为解决该问题，做如下优化：</p><h3 id="调整超时时间，和-buffer"><a href="#调整超时时间，和-buffer" class="headerlink" title="调整超时时间，和 buffer"></a>调整超时时间，和 buffer</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client_body_timeout 10s;</span><br><span class="line">client_header_timeout 10s;</span><br><span class="line">client_body_in_single_buffer on; #这个 directive 让 Nginx 将所有的 request body 存储在一个缓冲当中，它的默认值是 off。启用它可以优化读取 $request_body 变量时的 I/O 性能</span><br></pre></td></tr></table></figure><h3 id="开启-access-buffer-和-if"><a href="#开启-access-buffer-和-if" class="headerlink" title="开启 access buffer 和 if"></a>开启 access buffer 和 if</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log_format  main escape=json '[$log_time] [$logid] [INFO] $click_info';</span><br><span class="line"><span class="meta">#</span>设置变量loggable，默认$loggable=0;当$status==200时，$loggable=1</span><br><span class="line">map $status $loggable &#123;</span><br><span class="line">200  1;</span><br><span class="line">    default 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有真确处理了请求才会写日志。客户端在收到 408 时，会将 body 拆分重传。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着业务发展会出现较大的 post body 数据，按照&lt;a href=&quot;/2019/05/28/nginx-lua-开发中过程中-post
      
    
    </summary>
    
      <category term="Nginx" scheme="https://m.fanruo.net/categories/Nginx/"/>
    
      <category term="OpenResty" scheme="https://m.fanruo.net/categories/Nginx/OpenResty/"/>
    
    
      <category term="Nginx" scheme="https://m.fanruo.net/tags/Nginx/"/>
    
      <category term="OpenResty" scheme="https://m.fanruo.net/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>nginx + lua 开发中过程中 post body 过大返回 4xx</title>
    <link href="https://m.fanruo.net/2019/05/28/nginx-lua-%E5%BC%80%E5%8F%91%E4%B8%AD%E8%BF%87%E7%A8%8B%E4%B8%AD-post-body-%E8%BF%87%E5%A4%A7%E8%BF%94%E5%9B%9E-4xx/"/>
    <id>https://m.fanruo.net/2019/05/28/nginx-lua-开发中过程中-post-body-过大返回-4xx/</id>
    <published>2019-05-28T10:52:53.000Z</published>
    <updated>2019-05-28T10:54:07.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>基于 OpenResty 提供 post 接口，调用方调用该接口 post 数据，该接口接收 post 过来的数据，复用 Nginx access 日志落盘。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当用户的 body 体过大时，<code>ngx.req.get_body_data()</code> 读请求体，会出现读取不到直接返回 <code>nil</code> 的情况。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>究其原因，主要是 Nginx 诞生之初主要是为了解决负载均衡情况，而这种情况，是不需要读取 body 就可以决定负载策略的，所以这个点对于 API Server 和 Web Application 开发的同学有点怪。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>如果你只是某个接口需要读取 body（并非全局行为），那么这时候也可以显示调用 <code>ngx.req.read_body()</code> 接口</li><li>如果想全局生效的话需要使用命令<code>lua_need_request_body on;</code></li></ol><p>当选择上述其中一种，甚至两种方案都使用了，依旧还解决不了问题，这时候，需要坚持 body 体是不是太大了。这是需要设置如下两个命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client_body_buffer_size 256k; #默认8k|16k</span><br><span class="line">client_max_body_size 256k; #默认1m</span><br></pre></td></tr></table></figure></p><p>上述两条命令将强制将 body 写入内存，这样就可以读取较大的 body 体的数据了。</p><p>如果请求体已经被存入临时文件，请使用<code>ngx.req.get_body_file</code>函数代替。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;基于 OpenResty 提供 post 接口，调用方调用该接口 post 数据，该接口接收 post 过来的数据，复用 Nginx acc
      
    
    </summary>
    
      <category term="Nginx" scheme="https://m.fanruo.net/categories/Nginx/"/>
    
      <category term="OpenResty" scheme="https://m.fanruo.net/categories/Nginx/OpenResty/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="Nginx" scheme="https://m.fanruo.net/tags/Nginx/"/>
    
      <category term="OpenResty" scheme="https://m.fanruo.net/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>3.1 lua 函数</title>
    <link href="https://m.fanruo.net/2019/05/24/3-1-lua-%E5%87%BD%E6%95%B0/"/>
    <id>https://m.fanruo.net/2019/05/24/3-1-lua-函数/</id>
    <published>2019-05-24T02:52:03.000Z</published>
    <updated>2019-05-24T02:52:43.375Z</updated>
    
    <content type="html"><![CDATA[<p>通过前两章的学习大体掌握了lua的基本语法，这部分语法和其他语言大体类似，可以说这是一门语言语法的最最基础的部分了。在接下来的部分，将学习一下带有lua特性的语法知识。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>通常一个函数会返回一个返回值，比如C/C++等，也有一些语言会返回多个返回值，比如python。lua也支持多返回值。以标准库中的<code>string.find()</code>函数为例，该函数会返回匹配字符串在搜索字符串中的<strong>起始</strong>位置索引，如果没匹配成功则返回<code>nil</code>。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/bua</span><br><span class="line">s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">"hello world"</span>, <span class="string">"he"</span>)</span><br><span class="line"><span class="built_in">print</span>(s, e)</span><br></pre></td></tr></table></figure></p><p>对于返回值，lua有一个特性——尽可能的调整返回值的数量以适应调用环境，具体表现为一下规则：</p><ol><li>当作为调用表达式最后一个参数或者仅有的一个参数时，根据变量的数量尽可能多的返回值，当变量数目大余于返回值数目时补<code>nil</code>，当变量数小于返回值数目时从左到右依此返回，舍弃右边多余的返回值。</li><li>其他情况下，函数只返回第一个返回值。<br>总之，函数做作为最后一个参数时尽可能多返回返回值，其他情况只返回第一个返回值。<br>上述规则同样适用于以下情况：</li><li>作为表达式赋值给其他变量</li><li>作为其他函数的参数</li><li>函数调用在表构造初始化时</li><li>ruturn 参数<br>函数调用用在表构造初始化时需要特别说明一下：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_0</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_1</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">"a"</span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_2</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">"b"</span>, <span class="string">"c"</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = &#123;fun_0()&#125; <span class="comment">-- a = &#123;&#125;</span></span><br><span class="line">b = &#123;fun_1()&#125; <span class="comment">-- b = &#123;"a"&#125;</span></span><br><span class="line">c = &#123;fun_2()&#125; <span class="comment">-- c = &#123;"b", "c"&#125;</span></span><br><span class="line">d = &#123;fun_0(), fun_1(), fun_2(), <span class="string">"d"</span>&#125; <span class="comment">-- d = &#123;nil, "a", "b", "d"&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：如果<code>return</code>语句中将返回值用括号包裹起来也会导致返回一个值：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_3</span><span class="params">()</span></span> <span class="keyword">return</span> fun_2() <span class="keyword">end</span>  <span class="comment">-- "b", "c"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_4</span><span class="params">()</span></span> <span class="keyword">return</span> (fun_2()) <span class="keyword">end</span> <span class="comment">-- "b"</span></span><br></pre></td></tr></table></figure></p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>lua中函数是一等变量，可以通过关键字<code>function</code>来进行定义。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 和php等语言一样使用function关键字声明一个函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_a</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在lua中函数也是一等变量，可以通过如下方式来声明一个函数</span></span><br><span class="line"><span class="keyword">local</span> func_b = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>和其他语言一样，在lua中，声明一个函数可以指定固定数目的参数，这些参数不需要指定类型。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(a, b)</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>同样,lua也支持可变参数，使用<code>...</code>来表示可变参数：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_a</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(args) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--5.3.4中已不支持arg表了，改用...代替,见programing in lua 4th pp45</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_b</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(...) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>有时，我们会遇到这样一种情况：既需要若干固定参数，但还需要可变参数。这时我们需要将固定参数列在参数列表的最左边，可变参数<code>...</code>放在最右边。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_c</span><span class="params">(a, b, ...)</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>和其他语言一样，lua的参数和位置是相关的，函数调用时，实参会按照位置依次传递给形参。但是，有时我们记不住形参的具体位置就有麻烦了。命名参数就很好的解决了这个问题。<br>但是，和c++等语言的命名参数不一样，lua的命名参数是通过table来实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过前两章的学习大体掌握了lua的基本语法，这部分语法和其他语言大体类似，可以说这是一门语言语法的最最基础的部分了。在接下来的部分，将学习一下带有lua特性的语法知识。&lt;/p&gt;
&lt;h2 id=&quot;返回值&quot;&gt;&lt;a href=&quot;#返回值&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="函数" scheme="https://m.fanruo.net/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2.6 lua break 与 return</title>
    <link href="https://m.fanruo.net/2019/05/23/2-6-lua-break-%E4%B8%8E-return/"/>
    <id>https://m.fanruo.net/2019/05/23/2-6-lua-break-与-return/</id>
    <published>2019-05-23T00:56:53.000Z</published>
    <updated>2019-05-23T00:57:52.057Z</updated>
    
    <content type="html"><![CDATA[<p>和其他语言一样<code>lua</code>也提供对应的跳出关键字，不过<code>lua</code>不提供<code>continue</code>关键字。</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>语句<code>break</code>用于跳出循环，终止<code>for</code>、<code>repeat</code>、<code>while</code> 三种循环的执行，并跳出当前循环体，继续执行当前循环之后的语句,在循环外部不可用。</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>return 只能写在语句块的最后，一旦执行了return 语句，该语句之后的所有语句都不会再执行。若要写在函数中间，则只能写在一个显式的语句块内。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="comment">--print("add: I will return the result " .. (x + y))</span></span><br><span class="line">    <span class="comment">--因为前面有个return，若不注释该语句，则会报错</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">is_positive</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> x .. <span class="string">" is positive"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x .. <span class="string">" is non-positive"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--由于return只出现在前面显式的语句块，所以此语句不注释也不会报错</span></span><br><span class="line">    <span class="comment">--，但是不会被执行，此处不会产生输出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"function end!"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sum = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The sum is "</span> .. sum) <span class="comment">--&gt;output:The sum is 30</span></span><br><span class="line">answer = is_positive(<span class="number">-10</span>)</span><br><span class="line"><span class="built_in">print</span>(answer) <span class="comment">--&gt;output:-10 is non-positive</span></span><br></pre></td></tr></table></figure></p><p>有时候，为了调试方便，我们可以想在某个函数的中间提前 <code>return</code> ，以进行控制流的短路。此时我们可以将 <code>return</code> 放在一个 <code>do ... end</code> 代码块中:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"before"</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"after"</span>) <span class="comment">-- 这一行语句永远不会执行到</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p><strong>特别注意</strong>：上述实例中<code>return</code>如果不放在<code>do ... end</code>中将会保存，因为<code>return</code>只能放在函数的最后。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和其他语言一样&lt;code&gt;lua&lt;/code&gt;也提供对应的跳出关键字，不过&lt;code&gt;lua&lt;/code&gt;不提供&lt;code&gt;continue&lt;/code&gt;关键字。&lt;/p&gt;
&lt;h2 id=&quot;break&quot;&gt;&lt;a href=&quot;#break&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="语法" scheme="https://m.fanruo.net/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.5 lua 变量</title>
    <link href="https://m.fanruo.net/2019/05/21/2-5-lua-%E5%8F%98%E9%87%8F/"/>
    <id>https://m.fanruo.net/2019/05/21/2-5-lua-变量/</id>
    <published>2019-05-21T14:05:37.000Z</published>
    <updated>2019-05-21T14:06:30.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="创建一个全局变量"><a href="#创建一个全局变量" class="headerlink" title="创建一个全局变量"></a>创建一个全局变量</h3><p>全局变量不需要声明，给一个变量赋值即创建了一个全局变量，访问一个没有初始化的变量（默认是全局变量，即，lua的变量默认是全局变量，特别注意）也不会出错，会返回<code>nil</code>。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(var_a) <span class="comment">-- nil</span></span><br><span class="line">var_a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(var_a) <span class="comment">-- 10</span></span><br></pre></td></tr></table></figure></p><p>在命令模式中执行如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> print(var_a)</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="删除一个全局变量"><a href="#删除一个全局变量" class="headerlink" title="删除一个全局变量"></a>删除一个全局变量</h3><p>删除一个变量很简单，直接将改变量赋值为<code>nil</code>;如下面的例子：b是全局变量，当赋值为<code>nil</code>之后，再调用<code>print</code>就会返回<code>nil</code>。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> b = 1; print("b=" .. b); b = nil; print(b);</span><br><span class="line">b=1</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p><p>总之，可以这么理解：当一个变量被赋值为<code>nil</code>，这个变量就变得像从来没出现过一样，换句话说，<strong>只有当一个变量的值不是<code>nil</code>这个变量才是存在的</strong>。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>使用<code>local</code> 关键字来声明一个局部变量，和其他语言一样，局部变量只在被声明的那个代码块中有效。代码块包括：</p><ol><li>控制结构</li><li>函数体</li><li>chunk（变量被声明的那个文件或者文本串</li></ol><p><strong>注意</strong>:命令行模式中每一行就是一个chunk,也就是说，上一行的局部变量下一行就不可见了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> a = 1 -- 全局变量</span><br><span class="line"><span class="meta">&gt;</span> print(a)</span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span> local b = 2 -- 局部变量</span><br><span class="line"><span class="meta">&gt;</span> print(b)</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用do-end"><a href="#使用do-end" class="headerlink" title="使用do ... end"></a>使用<code>do ... end</code></h3><p>使用<code>do ... end</code>可以给一个block一个明确的边界。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> a = 1 --全局变量</span><br><span class="line"><span class="meta">&gt;</span> local b = 2 -- 局部变量</span><br><span class="line"><span class="meta">&gt;</span> do</span><br><span class="line"><span class="meta">&gt;</span>&gt; local c = a * 3 --局部变量</span><br><span class="line"><span class="meta">&gt;</span>&gt; print(a)</span><br><span class="line"><span class="meta">&gt;</span>&gt; print(b)</span><br><span class="line"><span class="meta">&gt;</span>&gt; print(c)</span><br><span class="line"><span class="meta">&gt;</span>&gt; end</span><br><span class="line">1</span><br><span class="line">nil</span><br><span class="line">3</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全局变量&quot;&gt;&lt;a href=&quot;#全局变量&quot; class=&quot;headerlink&quot; title=&quot;全局变量&quot;&gt;&lt;/a&gt;全局变量&lt;/h2&gt;&lt;h3 id=&quot;创建一个全局变量&quot;&gt;&lt;a href=&quot;#创建一个全局变量&quot; class=&quot;headerlink&quot; title=&quot;创
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="变量" scheme="https://m.fanruo.net/tags/%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>2.4 lua 控制结构</title>
    <link href="https://m.fanruo.net/2019/05/21/2-4-lua-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://m.fanruo.net/2019/05/21/2-4-lua-控制结构/</id>
    <published>2019-05-21T00:48:37.000Z</published>
    <updated>2019-05-21T08:34:57.618Z</updated>
    
    <content type="html"><![CDATA[<p>流程控制语句对于程序设计来说特别重要，它可以用于设定程序的逻辑结构。一般需要与条件判断语句结合使用。Lua 语言提供的控制结构有 if，while，repeat，for，并提供 break 关<br>键字来满足更丰富的需求。</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h2><p>if-else 是我们熟知的一种控制结构。Lua 跟其他语言一样，提供了 if-else 的控制结构。语法上更接近shell的语言，逻辑结构上和其他语言没有较大的区别，直接上实例，一看便知。</p><h3 id="单分支if-end"><a href="#单分支if-end" class="headerlink" title="单分支if-end"></a>单分支if-end</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a positive number"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--运行输出：x is a positive number</span></span><br></pre></td></tr></table></figure><h3 id="双分支if-else-end"><a href="#双分支if-else-end" class="headerlink" title="双分支if-else-end"></a>双分支if-else-end</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a positive number"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a non-positive number"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--运行输出：x is a positive number</span></span><br></pre></td></tr></table></figure><h3 id="多分支if-elseif-else-end"><a href="#多分支if-elseif-else-end" class="headerlink" title="多分支if-elseif-else-end"></a>多分支if-elseif-else-end</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> score == <span class="number">100</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Very good!Your score is 100"</span>)</span><br><span class="line"><span class="keyword">elseif</span> score &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Congratulations, you have passed it,your score greater or equal to 60"</span>)</span><br><span class="line"><span class="comment">--此处可以添加多个elseif</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Sorry, you do not pass the exam! "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--运行输出：Congratulations, you have passed it,your score greater or equal to 60</span></span><br></pre></td></tr></table></figure><p><strong>特别注意|</strong>与 C 语言的不同之处是 else 与 if 是连在一起的，若将 else 与 if 写成 “else if” 则相当于在else 里嵌套另一个 if 语句，如下代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> score == <span class="number">100</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Very good!Your score is 100"</span>)</span><br><span class="line"><span class="keyword">elseif</span> score &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Congratulations, you have passed it,your score greater or equal to 60"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> score &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Your score is better than 0"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My God, your score turned out to be 0"</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">--与上一示例代码不同的是，此处要添加一个end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>从上述实例中可以发现，除了<code>else if</code>这种形式较<code>elseif</code>多了一个<code>end</code>外看起来并没有什么区别。上述实例中<code>else if</code>在判断的最后，如果在中间的话，意味着后面的<code>elseif</code>将会出现语法错误。</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>Lua 跟其他常见语言一样，提供了 <code>while</code> 控制结构，语法上也没有什么特别的。但是没有提供do-while 型的控制结构，但是提供了功能相当的 <code>repeat</code>。<br><code>while</code> 型控制结构语法如下，当表达式值为假（ 即 <code>false</code> 或 <code>nil</code>） 时结束循环。也可以使用break 语言提前跳出循环。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式 <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例代码，求 1 + 2 + 3 + 4 + 5 的结果</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    sum = sum + x</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum) <span class="comment">--&gt;output 15</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong><br>Lua 并没有像许多其他语言那样提供类似 <code>continue</code> 这样的控制语句用来立即进入下一个循环迭代（ 如果有的话） 。因此，我们需要仔细地安排循环体里的分支，以避免这样的需求。</p><p>没有提供 <code>continue</code> ，却也提供了另外一个标准控制语句 <code>break</code> ，可以跳出当前循环。例如遍历 <code>table</code>，查找值为 <code>11</code> 的数组下标索引:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">21</span>&#125;</span><br><span class="line"><span class="keyword">local</span> i</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">11</span> == v <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index["</span> .. i .. <span class="string">"] have right value[11]"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p>Lua 中的 <code>repeat</code> 控制结构类似于其他语言（ 如：C++ 语言） 中的 do-while，但是控制方式是刚好相反的。简单点说，执行 <code>repeat</code> 循环体后，直到 <code>until</code> 的条件为<strong>真</strong>时才结束，而其他语言（ 如：C++ 语言） 的 do-while 则是当条件为假时就结束循环。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">until</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">--该代码将导致死循环，因为until的条件一直为假，循环不会结束</span></span><br></pre></td></tr></table></figure></p><p>除了条件相反外，<code>repeat</code>和<code>while</code>是一样的。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>for 语句有两种形式：数字 for（ numeric for） 和范型 for（ generic for）。</p><h3 id="数字for"><a href="#数字for" class="headerlink" title="数字for"></a>数字for</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var = begin, finish, step <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>关于数字 for 需要关注以下几点:</p><ol><li>var 从 begin 变化到 finish，每次变化都以 step 作为步长递增 var;</li><li>begin、finish、step 三个表达式只会在循环开始时执行一次;</li><li>第三个表达式 step是可选的，默认为 1;</li><li>控制变量 var 的作用域仅在 for 循环内，需要在外面控制，则需将值赋给一个新的变量;</li><li>循环过程中不要改变控制变量的值，那样会带来不可预知的影响.</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">10</span>, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果不想给循环设置上限的话，可以使用常量 math.huge：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0.3</span>*i^<span class="number">3</span> - <span class="number">20</span>*i^<span class="number">2</span> - <span class="number">500</span> &gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="泛型for"><a href="#泛型for" class="headerlink" title="泛型for"></a>泛型for</h3><p>泛型 for 循环通过一个迭代器（ iterator） 函数来遍历所有值：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印数组a的所有值</span></span><br><span class="line"><span class="keyword">local</span> a = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"index:"</span>, i, <span class="string">" value:"</span>, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index: 1 value: a</span><br><span class="line">index: 2 value: b</span><br><span class="line">index: 3 value: c</span><br><span class="line">index: 4 value: d</span><br></pre></td></tr></table></figure></p><p>注意到在上述实例中使用到<code>ipairs</code>函数。Lua 的基础库提供了<code>ipairs</code>，这是一个用于遍历<strong>数组</strong>的迭代器函数。在每次循环中，i 会被赋予一个索引值，同时 v 被赋予一个对应于该索引的数组元素值。那么如何遍历<code>table</code>呢？lua提供了<code>pairs</code>函数可以遍历<code>tbale</code>中的<code>key</code>.<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印table t中所有的key</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>从外观上看泛型 for 比较简单，但其实它是非常强大的。通过不同的迭代器，几乎可以遍历所有的东西， 而且写出的代码极具可读性。标准库提供了几种迭代器，包括用于迭代文件中每行的（ io.lines） 、 迭代 table 元素的（ pairs） 、迭代数组元素的（ ipairs） 、迭代字符串中单词的（ string.gmatch） 等。<br>泛型 for 循环与数字型 for 循环有两个相同点:</p><ol><li>循环变量是循环体的局部变量；</li><li>决不应该对循环变量作任何赋值。</li></ol><p><strong>特别注意：</strong>在 LuaJIT 2.1 中， ipairs() 内建函数是可以被 JIT 编译的，而 pairs() 则只能被解释执行。因此在性能敏感的场景，应当合理安排数据结构，避免对哈希表进行遍历。事实上，即使未来 pairs 可以被 JIT 编译，哈希表的遍历本身也不会有数组遍历那么高效，毕竟哈希表就不是为遍历而设计的数据结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;流程控制语句对于程序设计来说特别重要，它可以用于设定程序的逻辑结构。一般需要与条件判断语句结合使用。Lua 语言提供的控制结构有 if，while，repeat，for，并提供 break 关&lt;br&gt;键字来满足更丰富的需求。&lt;/p&gt;
&lt;h2 id=&quot;if-else&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="语言" scheme="https://m.fanruo.net/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>librdkafka 安装与使用</title>
    <link href="https://m.fanruo.net/2019/05/20/librdkafka-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://m.fanruo.net/2019/05/20/librdkafka-安装与使用/</id>
    <published>2019-05-20T00:53:02.000Z</published>
    <updated>2019-05-20T01:29:47.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-librdkafka"><a href="#安装-librdkafka" class="headerlink" title="安装 librdkafka"></a>安装 librdkafka</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/edenhill/librdkafka.git ./librdkafka</span><br><span class="line">cd ./librdkafka</span><br><span class="line">./configure</span><br><span class="line"><span class="meta">#</span> Or, to automatically install dependencies using the system's package manager:</span><br><span class="line"><span class="meta">#</span> ./configure --install-deps</span><br><span class="line"><span class="meta">#</span> Or, build dependencies from source:</span><br><span class="line"><span class="meta">#</span> ./configure --install-deps --source-deps-only</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="使用-librdkafka"><a href="#使用-librdkafka" class="headerlink" title="使用 librdkafka"></a>使用 librdkafka</h2><p>librdkafka 中自带 examples，cpp 目录下是 C++ 版本的包括两个 cpp 文件：consumer.cpp 和 producer.cpp，即生产者和消费者。修改其中 <code>brokers</code> 变量和 <code>topic_str</code> 变量的值。</p><p>consumer.cpp 文件的第58~63行修改如下（只修改了59行和61行，为看起来直观一些多粘了几行）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//broker 列表，可以用逗号隔开，只写其中一个也可以，这是线下测试环境</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> brokers = <span class="string">"10.159.1.40:19092,10.159.1.41:19092,10.159.1.42:19092"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> errstr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> topic_str=<span class="string">"test_mq"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; topics;</span><br><span class="line">topics.push_back(topic_str);</span><br></pre></td></tr></table></figure></p><p>producer.cpp 文件的第31~34行修改如下（只修改了32行和34行，为看起来直观一些多粘了几行）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//broker 列表，可以用逗号隔开，只写其中一个也可以，这是线下测试环境</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> brokers = <span class="string">"10.159.1.40:19092,10.159.1.41:19092,10.159.1.42:19092"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> errstr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> topic_str=<span class="string">"test_mq"</span>;</span><br></pre></td></tr></table></figure></p><p>编译 consumer.cpp 和 producer.cpp<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd ~/librdkafka/examples/cpp</span><br><span class="line"><span class="meta">$</span> g++ -o consumer consumer.cpp -lrdkafka++ -lrdkafka -lstdc++ -lbaas_c_style_interface -I~/librdkafka/include -L~/librdkafka/lib</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> g++ -o producer producer.cpp -lrdkafka++ -lrdkafka -lstdc++ -lbaas_c_style_interface -I~/librdkafka/include -L~/librdkafka/lib</span><br></pre></td></tr></table></figure></p><p>运行 producer 和 consumer （控制台交互式的程序，需要开两个窗口）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd ~/librdkafka/examples/cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./producer</span><br><span class="line"><span class="meta">%</span> Created producer rdkafka#producer-1</span><br><span class="line">hello world</span><br><span class="line"><span class="meta">%</span> Produced message (11 bytes)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./consumer</span><br><span class="line"><span class="meta">%</span> Created consumer rdkafka#consumer-1</span><br><span class="line">Read msg at offset 7</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-librdkafka&quot;&gt;&lt;a href=&quot;#安装-librdkafka&quot; class=&quot;headerlink&quot; title=&quot;安装 librdkafka&quot;&gt;&lt;/a&gt;安装 librdkafka&lt;/h2&gt;&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
      <category term="消息队列" scheme="https://m.fanruo.net/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="kafka" scheme="https://m.fanruo.net/tags/kafka/"/>
    
      <category term="消息队列" scheme="https://m.fanruo.net/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="librdkafka" scheme="https://m.fanruo.net/tags/librdkafka/"/>
    
      <category term="MQ" scheme="https://m.fanruo.net/tags/MQ/"/>
    
  </entry>
  
</feed>
