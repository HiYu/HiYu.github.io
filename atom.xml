<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡 若</title>
  
  <subtitle>初心 读书 知新 生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m.fanruo.net/"/>
  <updated>2019-05-28T10:54:07.730Z</updated>
  <id>https://m.fanruo.net/</id>
  
  <author>
    <name>Frank Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx + lua 开发中过程中 post body 过大返回 4xx</title>
    <link href="https://m.fanruo.net/2019/05/28/nginx-lua-%E5%BC%80%E5%8F%91%E4%B8%AD%E8%BF%87%E7%A8%8B%E4%B8%AD-post-body-%E8%BF%87%E5%A4%A7%E8%BF%94%E5%9B%9E-4xx/"/>
    <id>https://m.fanruo.net/2019/05/28/nginx-lua-开发中过程中-post-body-过大返回-4xx/</id>
    <published>2019-05-28T10:52:53.000Z</published>
    <updated>2019-05-28T10:54:07.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>基于 OpenResty 提供 post 接口，调用方调用该接口 post 数据，该接口接收 post 过来的数据，复用 Nginx access 日志落盘。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当用户的 body 体过大时，<code>ngx.req.get_body_data()</code> 读请求体，会出现读取不到直接返回 <code>nil</code> 的情况。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>究其原因，主要是 Nginx 诞生之初主要是为了解决负载均衡情况，而这种情况，是不需要读取 body 就可以决定负载策略的，所以这个点对于 API Server 和 Web Application 开发的同学有点怪。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>如果你只是某个接口需要读取 body（并非全局行为），那么这时候也可以显示调用 <code>ngx.req.read_body()</code> 接口</li><li>如果想全局生效的话需要使用命令<code>lua_need_request_body on;</code></li></ol><p>当选择上述其中一种，甚至两种方案都使用了，依旧还解决不了问题，这时候，需要坚持 body 体是不是太大了。这是需要设置如下两个命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client_body_buffer_size 256k; #默认8k|16k</span><br><span class="line">client_max_body_size 256k; #默认1m</span><br></pre></td></tr></table></figure></p><p>上述两条命令将强制将 body 写入内存，这样就可以读取较大的 body 体的数据了。</p><p>如果请求体已经被存入临时文件，请使用<code>ngx.req.get_body_file</code>函数代替。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;基于 OpenResty 提供 post 接口，调用方调用该接口 post 数据，该接口接收 post 过来的数据，复用 Nginx acc
      
    
    </summary>
    
      <category term="Nginx" scheme="https://m.fanruo.net/categories/Nginx/"/>
    
      <category term="OpenResty" scheme="https://m.fanruo.net/categories/Nginx/OpenResty/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="Nginx" scheme="https://m.fanruo.net/tags/Nginx/"/>
    
      <category term="OpenResty" scheme="https://m.fanruo.net/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>3.1 lua 函数</title>
    <link href="https://m.fanruo.net/2019/05/24/3-1-lua-%E5%87%BD%E6%95%B0/"/>
    <id>https://m.fanruo.net/2019/05/24/3-1-lua-函数/</id>
    <published>2019-05-24T02:52:03.000Z</published>
    <updated>2019-05-24T02:52:43.375Z</updated>
    
    <content type="html"><![CDATA[<p>通过前两章的学习大体掌握了lua的基本语法，这部分语法和其他语言大体类似，可以说这是一门语言语法的最最基础的部分了。在接下来的部分，将学习一下带有lua特性的语法知识。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>通常一个函数会返回一个返回值，比如C/C++等，也有一些语言会返回多个返回值，比如python。lua也支持多返回值。以标准库中的<code>string.find()</code>函数为例，该函数会返回匹配字符串在搜索字符串中的<strong>起始</strong>位置索引，如果没匹配成功则返回<code>nil</code>。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/bua</span><br><span class="line">s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">"hello world"</span>, <span class="string">"he"</span>)</span><br><span class="line"><span class="built_in">print</span>(s, e)</span><br></pre></td></tr></table></figure></p><p>对于返回值，lua有一个特性——尽可能的调整返回值的数量以适应调用环境，具体表现为一下规则：</p><ol><li>当作为调用表达式最后一个参数或者仅有的一个参数时，根据变量的数量尽可能多的返回值，当变量数目大余于返回值数目时补<code>nil</code>，当变量数小于返回值数目时从左到右依此返回，舍弃右边多余的返回值。</li><li>其他情况下，函数只返回第一个返回值。<br>总之，函数做作为最后一个参数时尽可能多返回返回值，其他情况只返回第一个返回值。<br>上述规则同样适用于以下情况：</li><li>作为表达式赋值给其他变量</li><li>作为其他函数的参数</li><li>函数调用在表构造初始化时</li><li>ruturn 参数<br>函数调用用在表构造初始化时需要特别说明一下：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_0</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_1</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">"a"</span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_2</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">"b"</span>, <span class="string">"c"</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = &#123;fun_0()&#125; <span class="comment">-- a = &#123;&#125;</span></span><br><span class="line">b = &#123;fun_1()&#125; <span class="comment">-- b = &#123;"a"&#125;</span></span><br><span class="line">c = &#123;fun_2()&#125; <span class="comment">-- c = &#123;"b", "c"&#125;</span></span><br><span class="line">d = &#123;fun_0(), fun_1(), fun_2(), <span class="string">"d"</span>&#125; <span class="comment">-- d = &#123;nil, "a", "b", "d"&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：如果<code>return</code>语句中将返回值用括号包裹起来也会导致返回一个值：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_3</span><span class="params">()</span></span> <span class="keyword">return</span> fun_2() <span class="keyword">end</span>  <span class="comment">-- "b", "c"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_4</span><span class="params">()</span></span> <span class="keyword">return</span> (fun_2()) <span class="keyword">end</span> <span class="comment">-- "b"</span></span><br></pre></td></tr></table></figure></p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>lua中函数是一等变量，可以通过关键字<code>function</code>来进行定义。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 和php等语言一样使用function关键字声明一个函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_a</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在lua中函数也是一等变量，可以通过如下方式来声明一个函数</span></span><br><span class="line"><span class="keyword">local</span> func_b = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>和其他语言一样，在lua中，声明一个函数可以指定固定数目的参数，这些参数不需要指定类型。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(a, b)</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>同样,lua也支持可变参数，使用<code>...</code>来表示可变参数：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_a</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(args) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--5.3.4中已不支持arg表了，改用...代替,见programing in lua 4th pp45</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_b</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(...) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>有时，我们会遇到这样一种情况：既需要若干固定参数，但还需要可变参数。这时我们需要将固定参数列在参数列表的最左边，可变参数<code>...</code>放在最右边。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_c</span><span class="params">(a, b, ...)</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>和其他语言一样，lua的参数和位置是相关的，函数调用时，实参会按照位置依次传递给形参。但是，有时我们记不住形参的具体位置就有麻烦了。命名参数就很好的解决了这个问题。<br>但是，和c++等语言的命名参数不一样，lua的命名参数是通过table来实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过前两章的学习大体掌握了lua的基本语法，这部分语法和其他语言大体类似，可以说这是一门语言语法的最最基础的部分了。在接下来的部分，将学习一下带有lua特性的语法知识。&lt;/p&gt;
&lt;h2 id=&quot;返回值&quot;&gt;&lt;a href=&quot;#返回值&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="函数" scheme="https://m.fanruo.net/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2.6 lua break 与 return</title>
    <link href="https://m.fanruo.net/2019/05/23/2-6-lua-break-%E4%B8%8E-return/"/>
    <id>https://m.fanruo.net/2019/05/23/2-6-lua-break-与-return/</id>
    <published>2019-05-23T00:56:53.000Z</published>
    <updated>2019-05-23T00:57:52.057Z</updated>
    
    <content type="html"><![CDATA[<p>和其他语言一样<code>lua</code>也提供对应的跳出关键字，不过<code>lua</code>不提供<code>continue</code>关键字。</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>语句<code>break</code>用于跳出循环，终止<code>for</code>、<code>repeat</code>、<code>while</code> 三种循环的执行，并跳出当前循环体，继续执行当前循环之后的语句,在循环外部不可用。</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>return 只能写在语句块的最后，一旦执行了return 语句，该语句之后的所有语句都不会再执行。若要写在函数中间，则只能写在一个显式的语句块内。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="comment">--print("add: I will return the result " .. (x + y))</span></span><br><span class="line">    <span class="comment">--因为前面有个return，若不注释该语句，则会报错</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">is_positive</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> x .. <span class="string">" is positive"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x .. <span class="string">" is non-positive"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--由于return只出现在前面显式的语句块，所以此语句不注释也不会报错</span></span><br><span class="line">    <span class="comment">--，但是不会被执行，此处不会产生输出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"function end!"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sum = add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The sum is "</span> .. sum) <span class="comment">--&gt;output:The sum is 30</span></span><br><span class="line">answer = is_positive(<span class="number">-10</span>)</span><br><span class="line"><span class="built_in">print</span>(answer) <span class="comment">--&gt;output:-10 is non-positive</span></span><br></pre></td></tr></table></figure></p><p>有时候，为了调试方便，我们可以想在某个函数的中间提前 <code>return</code> ，以进行控制流的短路。此时我们可以将 <code>return</code> 放在一个 <code>do ... end</code> 代码块中:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"before"</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"after"</span>) <span class="comment">-- 这一行语句永远不会执行到</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p><strong>特别注意</strong>：上述实例中<code>return</code>如果不放在<code>do ... end</code>中将会保存，因为<code>return</code>只能放在函数的最后。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和其他语言一样&lt;code&gt;lua&lt;/code&gt;也提供对应的跳出关键字，不过&lt;code&gt;lua&lt;/code&gt;不提供&lt;code&gt;continue&lt;/code&gt;关键字。&lt;/p&gt;
&lt;h2 id=&quot;break&quot;&gt;&lt;a href=&quot;#break&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="语法" scheme="https://m.fanruo.net/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.5 lua 变量</title>
    <link href="https://m.fanruo.net/2019/05/21/2-5-lua-%E5%8F%98%E9%87%8F/"/>
    <id>https://m.fanruo.net/2019/05/21/2-5-lua-变量/</id>
    <published>2019-05-21T14:05:37.000Z</published>
    <updated>2019-05-21T14:06:30.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="创建一个全局变量"><a href="#创建一个全局变量" class="headerlink" title="创建一个全局变量"></a>创建一个全局变量</h3><p>全局变量不需要声明，给一个变量赋值即创建了一个全局变量，访问一个没有初始化的变量（默认是全局变量，即，lua的变量默认是全局变量，特别注意）也不会出错，会返回<code>nil</code>。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(var_a) <span class="comment">-- nil</span></span><br><span class="line">var_a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(var_a) <span class="comment">-- 10</span></span><br></pre></td></tr></table></figure></p><p>在命令模式中执行如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> print(var_a)</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="删除一个全局变量"><a href="#删除一个全局变量" class="headerlink" title="删除一个全局变量"></a>删除一个全局变量</h3><p>删除一个变量很简单，直接将改变量赋值为<code>nil</code>;如下面的例子：b是全局变量，当赋值为<code>nil</code>之后，再调用<code>print</code>就会返回<code>nil</code>。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> b = 1; print("b=" .. b); b = nil; print(b);</span><br><span class="line">b=1</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p><p>总之，可以这么理解：当一个变量被赋值为<code>nil</code>，这个变量就变得像从来没出现过一样，换句话说，<strong>只有当一个变量的值不是<code>nil</code>这个变量才是存在的</strong>。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>使用<code>local</code> 关键字来声明一个局部变量，和其他语言一样，局部变量只在被声明的那个代码块中有效。代码块包括：</p><ol><li>控制结构</li><li>函数体</li><li>chunk（变量被声明的那个文件或者文本串</li></ol><p><strong>注意</strong>:命令行模式中每一行就是一个chunk,也就是说，上一行的局部变量下一行就不可见了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> a = 1 -- 全局变量</span><br><span class="line"><span class="meta">&gt;</span> print(a)</span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span> local b = 2 -- 局部变量</span><br><span class="line"><span class="meta">&gt;</span> print(b)</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用do-end"><a href="#使用do-end" class="headerlink" title="使用do ... end"></a>使用<code>do ... end</code></h3><p>使用<code>do ... end</code>可以给一个block一个明确的边界。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span> a = 1 --全局变量</span><br><span class="line"><span class="meta">&gt;</span> local b = 2 -- 局部变量</span><br><span class="line"><span class="meta">&gt;</span> do</span><br><span class="line"><span class="meta">&gt;</span>&gt; local c = a * 3 --局部变量</span><br><span class="line"><span class="meta">&gt;</span>&gt; print(a)</span><br><span class="line"><span class="meta">&gt;</span>&gt; print(b)</span><br><span class="line"><span class="meta">&gt;</span>&gt; print(c)</span><br><span class="line"><span class="meta">&gt;</span>&gt; end</span><br><span class="line">1</span><br><span class="line">nil</span><br><span class="line">3</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全局变量&quot;&gt;&lt;a href=&quot;#全局变量&quot; class=&quot;headerlink&quot; title=&quot;全局变量&quot;&gt;&lt;/a&gt;全局变量&lt;/h2&gt;&lt;h3 id=&quot;创建一个全局变量&quot;&gt;&lt;a href=&quot;#创建一个全局变量&quot; class=&quot;headerlink&quot; title=&quot;创
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="变量" scheme="https://m.fanruo.net/tags/%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>2.4 lua 控制结构</title>
    <link href="https://m.fanruo.net/2019/05/21/2-4-lua-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://m.fanruo.net/2019/05/21/2-4-lua-控制结构/</id>
    <published>2019-05-21T00:48:37.000Z</published>
    <updated>2019-05-21T08:34:57.618Z</updated>
    
    <content type="html"><![CDATA[<p>流程控制语句对于程序设计来说特别重要，它可以用于设定程序的逻辑结构。一般需要与条件判断语句结合使用。Lua 语言提供的控制结构有 if，while，repeat，for，并提供 break 关<br>键字来满足更丰富的需求。</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h2><p>if-else 是我们熟知的一种控制结构。Lua 跟其他语言一样，提供了 if-else 的控制结构。语法上更接近shell的语言，逻辑结构上和其他语言没有较大的区别，直接上实例，一看便知。</p><h3 id="单分支if-end"><a href="#单分支if-end" class="headerlink" title="单分支if-end"></a>单分支if-end</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a positive number"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--运行输出：x is a positive number</span></span><br></pre></td></tr></table></figure><h3 id="双分支if-else-end"><a href="#双分支if-else-end" class="headerlink" title="双分支if-else-end"></a>双分支if-else-end</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a positive number"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is a non-positive number"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--运行输出：x is a positive number</span></span><br></pre></td></tr></table></figure><h3 id="多分支if-elseif-else-end"><a href="#多分支if-elseif-else-end" class="headerlink" title="多分支if-elseif-else-end"></a>多分支if-elseif-else-end</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> score == <span class="number">100</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Very good!Your score is 100"</span>)</span><br><span class="line"><span class="keyword">elseif</span> score &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Congratulations, you have passed it,your score greater or equal to 60"</span>)</span><br><span class="line"><span class="comment">--此处可以添加多个elseif</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Sorry, you do not pass the exam! "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--运行输出：Congratulations, you have passed it,your score greater or equal to 60</span></span><br></pre></td></tr></table></figure><p><strong>特别注意|</strong>与 C 语言的不同之处是 else 与 if 是连在一起的，若将 else 与 if 写成 “else if” 则相当于在else 里嵌套另一个 if 语句，如下代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> score == <span class="number">100</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Very good!Your score is 100"</span>)</span><br><span class="line"><span class="keyword">elseif</span> score &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Congratulations, you have passed it,your score greater or equal to 60"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> score &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Your score is better than 0"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"My God, your score turned out to be 0"</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="comment">--与上一示例代码不同的是，此处要添加一个end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>从上述实例中可以发现，除了<code>else if</code>这种形式较<code>elseif</code>多了一个<code>end</code>外看起来并没有什么区别。上述实例中<code>else if</code>在判断的最后，如果在中间的话，意味着后面的<code>elseif</code>将会出现语法错误。</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>Lua 跟其他常见语言一样，提供了 <code>while</code> 控制结构，语法上也没有什么特别的。但是没有提供do-while 型的控制结构，但是提供了功能相当的 <code>repeat</code>。<br><code>while</code> 型控制结构语法如下，当表达式值为假（ 即 <code>false</code> 或 <code>nil</code>） 时结束循环。也可以使用break 语言提前跳出循环。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式 <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例代码，求 1 + 2 + 3 + 4 + 5 的结果</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    sum = sum + x</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum) <span class="comment">--&gt;output 15</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong><br>Lua 并没有像许多其他语言那样提供类似 <code>continue</code> 这样的控制语句用来立即进入下一个循环迭代（ 如果有的话） 。因此，我们需要仔细地安排循环体里的分支，以避免这样的需求。</p><p>没有提供 <code>continue</code> ，却也提供了另外一个标准控制语句 <code>break</code> ，可以跳出当前循环。例如遍历 <code>table</code>，查找值为 <code>11</code> 的数组下标索引:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">21</span>&#125;</span><br><span class="line"><span class="keyword">local</span> i</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">11</span> == v <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"index["</span> .. i .. <span class="string">"] have right value[11]"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p>Lua 中的 <code>repeat</code> 控制结构类似于其他语言（ 如：C++ 语言） 中的 do-while，但是控制方式是刚好相反的。简单点说，执行 <code>repeat</code> 循环体后，直到 <code>until</code> 的条件为<strong>真</strong>时才结束，而其他语言（ 如：C++ 语言） 的 do-while 则是当条件为假时就结束循环。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">until</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">--该代码将导致死循环，因为until的条件一直为假，循环不会结束</span></span><br></pre></td></tr></table></figure></p><p>除了条件相反外，<code>repeat</code>和<code>while</code>是一样的。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>for 语句有两种形式：数字 for（ numeric for） 和范型 for（ generic for）。</p><h3 id="数字for"><a href="#数字for" class="headerlink" title="数字for"></a>数字for</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var = begin, finish, step <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--body</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>关于数字 for 需要关注以下几点:</p><ol><li>var 从 begin 变化到 finish，每次变化都以 step 作为步长递增 var;</li><li>begin、finish、step 三个表达式只会在循环开始时执行一次;</li><li>第三个表达式 step是可选的，默认为 1;</li><li>控制变量 var 的作用域仅在 for 循环内，需要在外面控制，则需将值赋给一个新的变量;</li><li>循环过程中不要改变控制变量的值，那样会带来不可预知的影响.</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">10</span>, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果不想给循环设置上限的话，可以使用常量 math.huge：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0.3</span>*i^<span class="number">3</span> - <span class="number">20</span>*i^<span class="number">2</span> - <span class="number">500</span> &gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="泛型for"><a href="#泛型for" class="headerlink" title="泛型for"></a>泛型for</h3><p>泛型 for 循环通过一个迭代器（ iterator） 函数来遍历所有值：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印数组a的所有值</span></span><br><span class="line"><span class="keyword">local</span> a = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"index:"</span>, i, <span class="string">" value:"</span>, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index: 1 value: a</span><br><span class="line">index: 2 value: b</span><br><span class="line">index: 3 value: c</span><br><span class="line">index: 4 value: d</span><br></pre></td></tr></table></figure></p><p>注意到在上述实例中使用到<code>ipairs</code>函数。Lua 的基础库提供了<code>ipairs</code>，这是一个用于遍历<strong>数组</strong>的迭代器函数。在每次循环中，i 会被赋予一个索引值，同时 v 被赋予一个对应于该索引的数组元素值。那么如何遍历<code>table</code>呢？lua提供了<code>pairs</code>函数可以遍历<code>tbale</code>中的<code>key</code>.<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印table t中所有的key</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>从外观上看泛型 for 比较简单，但其实它是非常强大的。通过不同的迭代器，几乎可以遍历所有的东西， 而且写出的代码极具可读性。标准库提供了几种迭代器，包括用于迭代文件中每行的（ io.lines） 、 迭代 table 元素的（ pairs） 、迭代数组元素的（ ipairs） 、迭代字符串中单词的（ string.gmatch） 等。<br>泛型 for 循环与数字型 for 循环有两个相同点:</p><ol><li>循环变量是循环体的局部变量；</li><li>决不应该对循环变量作任何赋值。</li></ol><p><strong>特别注意：</strong>在 LuaJIT 2.1 中， ipairs() 内建函数是可以被 JIT 编译的，而 pairs() 则只能被解释执行。因此在性能敏感的场景，应当合理安排数据结构，避免对哈希表进行遍历。事实上，即使未来 pairs 可以被 JIT 编译，哈希表的遍历本身也不会有数组遍历那么高效，毕竟哈希表就不是为遍历而设计的数据结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;流程控制语句对于程序设计来说特别重要，它可以用于设定程序的逻辑结构。一般需要与条件判断语句结合使用。Lua 语言提供的控制结构有 if，while，repeat，for，并提供 break 关&lt;br&gt;键字来满足更丰富的需求。&lt;/p&gt;
&lt;h2 id=&quot;if-else&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="语言" scheme="https://m.fanruo.net/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>librdkafka 安装与使用</title>
    <link href="https://m.fanruo.net/2019/05/20/librdkafka-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://m.fanruo.net/2019/05/20/librdkafka-安装与使用/</id>
    <published>2019-05-20T00:53:02.000Z</published>
    <updated>2019-05-20T01:29:47.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-librdkafka"><a href="#安装-librdkafka" class="headerlink" title="安装 librdkafka"></a>安装 librdkafka</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/edenhill/librdkafka.git ./librdkafka</span><br><span class="line">cd ./librdkafka</span><br><span class="line">./configure</span><br><span class="line"><span class="meta">#</span> Or, to automatically install dependencies using the system's package manager:</span><br><span class="line"><span class="meta">#</span> ./configure --install-deps</span><br><span class="line"><span class="meta">#</span> Or, build dependencies from source:</span><br><span class="line"><span class="meta">#</span> ./configure --install-deps --source-deps-only</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="使用-librdkafka"><a href="#使用-librdkafka" class="headerlink" title="使用 librdkafka"></a>使用 librdkafka</h2><p>librdkafka 中自带 examples，cpp 目录下是 C++ 版本的包括两个 cpp 文件：consumer.cpp 和 producer.cpp，即生产者和消费者。修改其中 <code>brokers</code> 变量和 <code>topic_str</code> 变量的值。</p><p>consumer.cpp 文件的第58~63行修改如下（只修改了59行和61行，为看起来直观一些多粘了几行）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//broker 列表，可以用逗号隔开，只写其中一个也可以，这是线下测试环境</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> brokers = <span class="string">"10.159.1.40:19092,10.159.1.41:19092,10.159.1.42:19092"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> errstr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> topic_str=<span class="string">"test_mq"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; topics;</span><br><span class="line">topics.push_back(topic_str);</span><br></pre></td></tr></table></figure></p><p>producer.cpp 文件的第31~34行修改如下（只修改了32行和34行，为看起来直观一些多粘了几行）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//broker 列表，可以用逗号隔开，只写其中一个也可以，这是线下测试环境</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> brokers = <span class="string">"10.159.1.40:19092,10.159.1.41:19092,10.159.1.42:19092"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> errstr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> topic_str=<span class="string">"test_mq"</span>;</span><br></pre></td></tr></table></figure></p><p>编译 consumer.cpp 和 producer.cpp<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd ~/librdkafka/examples/cpp</span><br><span class="line"><span class="meta">$</span> g++ -o consumer consumer.cpp -lrdkafka++ -lrdkafka -lstdc++ -lbaas_c_style_interface -I~/librdkafka/include -L~/librdkafka/lib</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> g++ -o producer producer.cpp -lrdkafka++ -lrdkafka -lstdc++ -lbaas_c_style_interface -I~/librdkafka/include -L~/librdkafka/lib</span><br></pre></td></tr></table></figure></p><p>运行 producer 和 consumer （控制台交互式的程序，需要开两个窗口）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd ~/librdkafka/examples/cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./producer</span><br><span class="line"><span class="meta">%</span> Created producer rdkafka#producer-1</span><br><span class="line">hello world</span><br><span class="line"><span class="meta">%</span> Produced message (11 bytes)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./consumer</span><br><span class="line"><span class="meta">%</span> Created consumer rdkafka#consumer-1</span><br><span class="line">Read msg at offset 7</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-librdkafka&quot;&gt;&lt;a href=&quot;#安装-librdkafka&quot; class=&quot;headerlink&quot; title=&quot;安装 librdkafka&quot;&gt;&lt;/a&gt;安装 librdkafka&lt;/h2&gt;&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
      <category term="消息队列" scheme="https://m.fanruo.net/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="kafka" scheme="https://m.fanruo.net/tags/kafka/"/>
    
      <category term="消息队列" scheme="https://m.fanruo.net/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="librdkafka" scheme="https://m.fanruo.net/tags/librdkafka/"/>
    
      <category term="MQ" scheme="https://m.fanruo.net/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>搭建 kafka 测试集群</title>
    <link href="https://m.fanruo.net/2019/05/20/%E6%90%AD%E5%BB%BA-kafka-%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4/"/>
    <id>https://m.fanruo.net/2019/05/20/搭建-kafka-测试集群/</id>
    <published>2019-05-19T16:02:21.000Z</published>
    <updated>2019-05-19T16:07:28.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="申请机器"><a href="#申请机器" class="headerlink" title="申请机器"></a>申请机器</h2><p>联系OP同学申请机器，Linux服务器一台、三台、五台、（2*n+1），Zookeeper集群的工作是超过半数才能对外提供服务，3台中超过两台超过半数，允许1台挂掉 ，是否可用偶数，其实没必要。<br><strong>如果有四台那么挂掉一台还剩下三台服务器，如果在挂掉一个就不行了，这里记住是超过半数</strong>。<br>找到如下 3 台机器：</p><blockquote><p>10.159.1.40<br>10.159.1.41<br>10.159.1.42</p></blockquote><h2 id="安装基础环境"><a href="#安装基础环境" class="headerlink" title="安装基础环境"></a>安装基础环境</h2><p>安装Java环境支持，需要安装sun-java8，不再赘述。</p><h2 id="目录规划"><a href="#目录规划" class="headerlink" title="目录规划"></a>目录规划</h2><p>首先要注意在生产环境中目录结构要定义好，防止在项目过多的时候找不到所需的项目。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pwd</span><br><span class="line">/home/work</span><br><span class="line"><span class="meta">$</span> mkdir opt</span><br><span class="line"><span class="meta">$</span> cd opt</span><br><span class="line"><span class="meta">$</span> mkdir zookeeper</span><br><span class="line"><span class="meta">$</span> mkdir kafka</span><br><span class="line"><span class="meta">$</span> tree -L 1</span><br><span class="line">.</span><br><span class="line">├── kafka</span><br><span class="line">└── zookeeper</span><br><span class="line"></span><br><span class="line">2 directories, 0 files</span><br></pre></td></tr></table></figure></p><h2 id="搭建zookeeper集群"><a href="#搭建zookeeper集群" class="headerlink" title="搭建zookeeper集群"></a>搭建zookeeper集群</h2><h3 id="安装配置zookeeper"><a href="#安装配置zookeeper" class="headerlink" title="安装配置zookeeper"></a>安装配置zookeeper</h3><h4 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pwd</span><br><span class="line">/home/work</span><br><span class="line"><span class="meta">$</span> wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz</span><br><span class="line"><span class="meta">#</span> 如果机器没有外网权限需要通过scp等方法来获取zookeeper-3.4.13.tar.gz</span><br><span class="line"><span class="meta">$</span> cd /home/work/opt/zookeeper</span><br><span class="line"><span class="meta">$</span> tar -zxvf /home/work/zookeeper-3.4.13.tar.gz</span><br><span class="line">mkdir zkdata #存放快照日志</span><br><span class="line">mkdir zkdatalog #存放事物日志</span><br></pre></td></tr></table></figure><h4 id="配置zookeeper"><a href="#配置zookeeper" class="headerlink" title="配置zookeeper"></a>配置zookeeper</h4><p>查看conf目录，在该目录zoo_sample.cfg文件是官方给我们的zookeeper的样板文件，给他复制一份命名为zoo.cfg，zoo.cfg是官方指定的文件命名规则。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ll /home/work/opt/zookeeper/zookeeper-3.4.13/conf/ -tr</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r-- 1 work work  922 Jun 30 01:04 zoo_sample.cfg</span><br><span class="line">-rw-r--r-- 1 work work 2161 Jun 30 01:04 log4j.properties</span><br><span class="line">-rw-r--r-- 1 work work  535 Jun 30 01:04 configuration.xsl</span><br></pre></td></tr></table></figure></p><p>修改<code>zoo.cfg</code>文件内容如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta">#</span> The number of ticks that the initial</span><br><span class="line"><span class="meta">#</span> synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta">#</span> The number of ticks that can pass between</span><br><span class="line"><span class="meta">#</span> sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta">#</span> the directory where the snapshot is stored.</span><br><span class="line"><span class="meta">#</span> do not use /tmp for storage, /tmp here is just</span><br><span class="line"><span class="meta">#</span> example sakes.</span><br><span class="line">dataDir=/home/work/opt/zookeeper/zkdata</span><br><span class="line">dataLogDir=/home/work/opt/zookeeper/zkdatalog</span><br><span class="line"><span class="meta">#</span> the port at which the clients will connect</span><br><span class="line">clientPort=12181</span><br><span class="line">server.1=10.159.1.40:12888:13888</span><br><span class="line">server.2=10.159.1.41:12888:13888</span><br><span class="line">server.3=10.159.1.42:12888:13888</span><br></pre></td></tr></table></figure></p><h4 id="创建myid文件"><a href="#创建myid文件" class="headerlink" title="创建myid文件"></a>创建myid文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>在server1上执行</span><br><span class="line">echo "1" &gt; /home/work/opt/zookeeper/zkdata/myid</span><br><span class="line"><span class="meta">#</span>在server2上执行</span><br><span class="line">echo "2" &gt; /home/work/opt/zookeeper/zkdata/myid</span><br><span class="line"><span class="meta">#</span>在server3上执行</span><br><span class="line">echo "3" &gt; /home/work/opt/zookeeper/zkdata/myid</span><br></pre></td></tr></table></figure><h3 id="确认zookeeper是否部署成功"><a href="#确认zookeeper是否部署成功" class="headerlink" title="确认zookeeper是否部署成功"></a>确认zookeeper是否部署成功</h3><h4 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>进入到Zookeeper的bin目录下</span><br><span class="line"><span class="meta">$</span> cd /home/work/opt/zookeeper/zookeeper-3.4.13/bin</span><br><span class="line"><span class="meta">#</span>启动服务（3台都需要操作）</span><br><span class="line"><span class="meta">$</span> ./zkServer.sh start</span><br></pre></td></tr></table></figure><h4 id="检查是否启动成功"><a href="#检查是否启动成功" class="headerlink" title="检查是否启动成功"></a>检查是否启动成功</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>检查服务器状态</span><br><span class="line"><span class="meta">$</span> ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/work/opt/zookeeper/zookeeper-3.4.13/bin/../conf/zoo.cfg # 使用的具体配置文件</span><br><span class="line">Mode: follower #是否为leaderzk</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>集群一般只有一个leader，多个follower，主一般是相应客户端的读写请求，而从主同步数据，当主挂掉之后就会从follower里投票选举一个leader出来。</p><p>另外，可以用<code>jps</code>查看zk的进程，这个是zk的整个工程的main<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jps</span><br><span class="line">48642 QuorumPeerMain</span><br><span class="line">19551 Jps</span><br></pre></td></tr></table></figure></p><h2 id="搭建kafka集群"><a href="#搭建kafka集群" class="headerlink" title="搭建kafka集群"></a>搭建kafka集群</h2><h3 id="安装配置kafka"><a href="#安装配置kafka" class="headerlink" title="安装配置kafka"></a>安装配置kafka</h3><h4 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd ~</span><br><span class="line"><span class="meta">$</span> pwd</span><br><span class="line">/home/work</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> wget https://www.apache.org/dyn/closer.cgi?path=/kafka/2.0.0/kafka_2.12-2.0.0.tgz</span><br><span class="line"><span class="meta">$</span> cd /home/work/opt/kafka</span><br><span class="line"><span class="meta">$</span> tar -zxvf /home/work/kafka_2.12-2.0.0.tgz</span><br><span class="line"><span class="meta">$</span> mkdir kafkalogs # 创建kafka消息目录，主要存放kafka消息</span><br></pre></td></tr></table></figure><h4 id="配置kafka"><a href="#配置kafka" class="headerlink" title="配置kafka"></a>配置kafka</h4><p>进入到config目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/work/opt/kafka/kafka_2.11-2.0.0/config</span><br></pre></td></tr></table></figure></p><p>主要关注：<code>server.properties</code>这个文件即可，我们可以发现在目录下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ll</span><br><span class="line">total 68</span><br><span class="line">-rw-r--r-- 1 work work  906 Jul 24 22:17 connect-console-sink.properties</span><br><span class="line">-rw-r--r-- 1 work work  909 Jul 24 22:17 connect-console-source.properties</span><br><span class="line">-rw-r--r-- 1 work work 5321 Jul 24 22:17 connect-distributed.properties</span><br><span class="line">-rw-r--r-- 1 work work  883 Jul 24 22:17 connect-file-sink.properties</span><br><span class="line">-rw-r--r-- 1 work work  881 Jul 24 22:17 connect-file-source.properties</span><br><span class="line">-rw-r--r-- 1 work work 1111 Jul 24 22:17 connect-log4j.properties</span><br><span class="line">-rw-r--r-- 1 work work 2262 Jul 24 22:17 connect-standalone.properties</span><br><span class="line">-rw-r--r-- 1 work work 1221 Jul 24 22:17 consumer.properties</span><br><span class="line">-rw-r--r-- 1 work work 4727 Jul 24 22:17 log4j.properties</span><br><span class="line">-rw-r--r-- 1 work work 1919 Jul 24 22:17 producer.properties</span><br><span class="line">-rw-r--r-- 1 work work 7025 Oct 24 11:42 server.properties</span><br><span class="line">-rw-r--r-- 1 work work 1032 Jul 24 22:17 tools-log4j.properties</span><br><span class="line">-rw-r--r-- 1 work work 1169 Jul 24 22:17 trogdor.conf</span><br><span class="line">-rw-r--r-- 1 work work 1023 Jul 24 22:17 zookeeper.properties</span><br></pre></td></tr></table></figure></p><p>有很多文件，这里可以发现有Zookeeper文件，我们可以根据Kafka内带的zk集群来启动，但是建议使用独立的zk集群。<br>修改配置文件<code>server.properties</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line"><span class="meta">#</span> contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line"><span class="meta">#</span> this work for additional information regarding copyright ownership.</span><br><span class="line"><span class="meta">#</span> The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line"><span class="meta">#</span> (the "License"); you may not use this file except in compliance with</span><br><span class="line"><span class="meta">#</span> the License.  You may obtain a copy of the License at</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Unless required by applicable law or agreed to in writing, software</span><br><span class="line"><span class="meta">#</span> distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"><span class="meta">#</span> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"><span class="meta">#</span> See the License for the specific language governing permissions and</span><br><span class="line"><span class="meta">#</span> limitations under the License.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> see kafka.server.KafkaConfig for additional details and defaults</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Server Basics #############################</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The id of the broker. This must be set to a unique integer for each broker.</span><br><span class="line">broker.id=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Socket Server Settings #############################</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The address the socket server listens on. It will get the value returned from</span><br><span class="line"><span class="meta">#</span> java.net.InetAddress.getCanonicalHostName() if not configured.</span><br><span class="line"><span class="meta">#</span>   FORMAT:</span><br><span class="line"><span class="meta">#</span>     listeners = listener_name://host_name:port</span><br><span class="line"><span class="meta">#</span>   EXAMPLE:</span><br><span class="line"><span class="meta">#</span>     listeners = PLAINTEXT://your.host.name:9092</span><br><span class="line"><span class="meta">#</span>listeners=PLAINTEXT://:9092</span><br><span class="line"></span><br><span class="line">host.name=10.159.1.40</span><br><span class="line">port=19092</span><br><span class="line"><span class="meta">#</span> Hostname and port the broker will advertise to producers and consumers. If not set,</span><br><span class="line"><span class="meta">#</span> it uses the value for "listeners" if configured.  Otherwise, it will use the value</span><br><span class="line"><span class="meta">#</span> returned from java.net.InetAddress.getCanonicalHostName().</span><br><span class="line"><span class="meta">#</span>advertised.listeners=PLAINTEXT://your.host.name:9092</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Maps listener names to security protocols, the default is for them to be the same. See the config documentation for more details</span><br><span class="line"><span class="meta">#</span>listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The number of threads that the server uses for receiving requests from the network and sending responses to the network</span><br><span class="line">num.network.threads=3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The number of threads that the server uses for processing requests, which may include disk I/O</span><br><span class="line">num.io.threads=8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The send buffer (SO_SNDBUF) used by the socket server</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The receive buffer (SO_RCVBUF) used by the socket server</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The maximum size of a request that the socket server will accept (protection against OOM)</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Log Basics #############################</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> A comma separated list of directories under which to store log files</span><br><span class="line">log.dirs=/home/work/opt/kafka/kafkalogs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The default number of log partitions per topic. More partitions allow greater</span><br><span class="line"><span class="meta">#</span> parallelism for consumption, but this will also result in more files across</span><br><span class="line"><span class="meta">#</span> the brokers.</span><br><span class="line">num.partitions=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.</span><br><span class="line"><span class="meta">#</span> This value is recommended to be increased for installations with data dirs located in RAID array.</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Internal Topic Settings  #############################</span><br><span class="line"><span class="meta">#</span> The replication factor for the group metadata internal topics "__consumer_offsets" and "__transaction_state"</span><br><span class="line"><span class="meta">#</span> For anything other than development testing, a value greater than 1 is recommended for to ensure availability such as 3.</span><br><span class="line">offsets.topic.replication.factor=1</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Log Flush Policy #############################</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Messages are immediately written to the filesystem but by default we only fsync() to sync</span><br><span class="line"><span class="meta">#</span> the OS cache lazily. The following configurations control the flush of data to disk.</span><br><span class="line"><span class="meta">#</span> There are a few important trade-offs here:</span><br><span class="line"><span class="meta">#</span>    1. Durability: Unflushed data may be lost if you are not using replication.</span><br><span class="line"><span class="meta">#</span>    2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush.</span><br><span class="line"><span class="meta">#</span>    3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to excessive seeks.</span><br><span class="line"><span class="meta">#</span> The settings below allow one to configure the flush policy to flush data after a period of time or</span><br><span class="line"><span class="meta">#</span> every N messages (or both). This can be done globally and overridden on a per-topic basis.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The number of messages to accept before forcing a flush of data to disk</span><br><span class="line"><span class="meta">#</span>log.flush.interval.messages=10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The maximum amount of time a message can sit in a log before we force a flush</span><br><span class="line"><span class="meta">#</span>log.flush.interval.ms=1000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Log Retention Policy #############################</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The following configurations control the disposal of log segments. The policy can</span><br><span class="line"><span class="meta">#</span> be set to delete segments after a period of time, or after a given size has accumulated.</span><br><span class="line"><span class="meta">#</span> A segment will be deleted whenever *either* of these criteria are met. Deletion always happens</span><br><span class="line"><span class="meta">#</span> from the end of the log.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The minimum age of a log file to be eligible for deletion due to age</span><br><span class="line">log.retention.hours=168</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> A size-based retention policy for logs. Segments are pruned from the log unless the remaining</span><br><span class="line"><span class="meta">#</span> segments drop below log.retention.bytes. Functions independently of log.retention.hours.</span><br><span class="line"><span class="meta">#</span>log.retention.bytes=1073741824</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The maximum size of a log segment file. When this size is reached a new log segment will be created.</span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The interval at which log segments are checked to see if they can be deleted according</span><br><span class="line"><span class="meta">#</span> to the retention policies</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Zookeeper #############################</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Zookeeper connection string (see zookeeper docs for details).</span><br><span class="line"><span class="meta">#</span> This is a comma separated host:port pairs, each corresponding to a zk</span><br><span class="line"><span class="meta">#</span> server. e.g. "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002".</span><br><span class="line"><span class="meta">#</span> You can also append an optional chroot string to the urls to specify the</span><br><span class="line"><span class="meta">#</span> root directory for all kafka znodes.</span><br><span class="line">zookeeper.connect=10.159.1.40:12181,10.159.1.41:12181,10.159.1.42:12181</span><br><span class="line">message.max.byte=5242880</span><br><span class="line">default.replication.factor=2</span><br><span class="line">replica.fetch.max.bytes=5242880</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Timeout in ms for connecting to zookeeper</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>############################ Group Coordinator Settings #############################</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The following configuration specifies the time, in milliseconds, that the GroupCoordinator will delay the initial consumer rebalance.</span><br><span class="line"><span class="meta">#</span> The rebalance will be further delayed by the value of group.initial.rebalance.delay.ms as new members join the group, up to a maximum of max.poll.interval.ms.</span><br><span class="line"><span class="meta">#</span> The default value for this is 3 seconds.</span><br><span class="line"><span class="meta">#</span> We override this to 0 here as it makes for a better out-of-the-box experience for development and testing.</span><br><span class="line"><span class="meta">#</span> However, in production environments the default value of 3 seconds is more suitable as this will help to avoid unnecessary, and potentially expensive, rebalances during application startup.</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure></p><h3 id="确认kafka是否部署成功"><a href="#确认kafka是否部署成功" class="headerlink" title="确认kafka是否部署成功"></a>确认kafka是否部署成功</h3><h4 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /home/work/opt/kafka/kafka_2.11-2.0.0/bin</span><br><span class="line"><span class="meta">$</span> ./kafka-server-start.sh  -daemon ../config/server.properties</span><br></pre></td></tr></table></figure><h4 id="检查是否启动成功-1"><a href="#检查是否启动成功-1" class="headerlink" title="检查是否启动成功"></a>检查是否启动成功</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jps # 查看kafka是否启动成功</span><br><span class="line">48642 QuorumPeerMain</span><br><span class="line">55722 Jps</span><br><span class="line">25868 Kafka</span><br></pre></td></tr></table></figure><p><strong>tips：</strong>上述只是一台机器上搭建zookeeper和kafka，其他两台机器做上述同样操作</p><h2 id="测试kafka功能"><a href="#测试kafka功能" class="headerlink" title="测试kafka功能"></a>测试kafka功能</h2><h3 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper 10.159.1.41:12181 --replication-factor 2 --partitions 1 --topic test_mq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> --replication-factor 2 复制两份</span><br><span class="line"><span class="meta">#</span> --partitions 1 创建1个分区</span><br><span class="line"><span class="meta">#</span> --topic 主题为test_mq</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./kafka-topics.sh --list --zookeeper localhost:12181</span><br><span class="line">test_mq</span><br></pre></td></tr></table></figure><h3 id="生成-amp-消费消息"><a href="#生成-amp-消费消息" class="headerlink" title="生成&amp;消费消息"></a>生成&amp;消费消息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在10.159.1.40机器上执行,并在&gt;提示提示符后输入msg</span><br><span class="line"><span class="meta">$</span> ./kafka-console-producer.sh --broker-list 10.159.1.40:19092 --topic test_mq</span><br><span class="line"><span class="meta">&gt;</span> test mq message</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在10.159.1.41机器上执行，可以看到收到了消息</span><br><span class="line"><span class="meta">$</span> ./kafka-console-consumer.sh --bootstrap-server PLAINTEXT://10.159.1.41:19092 --topic test_mq --from-beginning</span><br><span class="line">test mq message</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在10.159.1.42机器上执行，可以看到收到了消息</span><br><span class="line"><span class="meta">$</span> ./kafka-console-consumer.sh --bootstrap-server PLAINTEXT://10.159.1.42:19092 --topic test_mq --from-beginning</span><br><span class="line">test mq message</span><br></pre></td></tr></table></figure><p>至此，kafka集群搭建成功。后续还需要优化</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>多boker调研</li><li>参数优化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;申请机器&quot;&gt;&lt;a href=&quot;#申请机器&quot; class=&quot;headerlink&quot; title=&quot;申请机器&quot;&gt;&lt;/a&gt;申请机器&lt;/h2&gt;&lt;p&gt;联系OP同学申请机器，Linux服务器一台、三台、五台、（2*n+1），Zookeeper集群的工作是超过半数才能对外提供服
      
    
    </summary>
    
      <category term="消息队列" scheme="https://m.fanruo.net/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="kafka" scheme="https://m.fanruo.net/tags/kafka/"/>
    
      <category term="消息队列" scheme="https://m.fanruo.net/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>2.3 lua 表达式</title>
    <link href="https://m.fanruo.net/2019/05/19/2-3-lua-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://m.fanruo.net/2019/05/19/2-3-lua-表达式/</id>
    <published>2019-05-19T15:44:58.000Z</published>
    <updated>2019-05-21T08:34:42.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><p>Lua 的算术运算符如下表所示：</p><table><thead><tr><th>表达符</th><th>备注</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>^</td><td>指数</td></tr><tr><td>%</td><td>取模</td></tr></tbody></table><p>实例<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + <span class="number">2</span>) <span class="comment">--&gt;打印 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> / <span class="number">10</span>) <span class="comment">--&gt;打印 0.5。 这是Lua不同于c语言的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5.0</span> / <span class="number">10</span>) <span class="comment">--&gt;打印 0.5。 浮点数相除的结果是浮点数</span></span><br><span class="line"><span class="comment">-- print(10 / 0) --&gt;注意除数不能为0，计算的结果会出错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> ^ <span class="number">10</span>) <span class="comment">--&gt;打印 1024。 求2的10次方</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">1357</span></span><br><span class="line"><span class="built_in">print</span>(num % <span class="number">2</span>) <span class="comment">--&gt;打印 1</span></span><br><span class="line"><span class="built_in">print</span>((num % <span class="number">2</span>) == <span class="number">1</span>) <span class="comment">--&gt;打印 true。 判断num是否为奇数</span></span><br><span class="line"><span class="built_in">print</span>((num % <span class="number">5</span>) == <span class="number">0</span>) <span class="comment">--&gt;打印 false。判断num是否能被5整数</span></span><br></pre></td></tr></table></figure></p><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><table><thead><tr><th>表达符</th><th>备注</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>~=</td><td>不等于</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> &lt; <span class="number">2</span>) <span class="comment">--&gt;打印 true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> == <span class="number">2</span>) <span class="comment">--&gt;打印 false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> ~= <span class="number">2</span>) <span class="comment">--&gt;打印 true</span></span><br><span class="line"><span class="keyword">local</span> a, b = <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line"><span class="built_in">print</span>(a == b) <span class="comment">--&gt;打印 false</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong></p><ol><li>不同于C/C++等语言，lua中的“不等于”是<code>~=</code>而非<code>!=</code>.</li><li>由于 Lua 字符串总是会被“内化”，即相同内容的字符串只会被保存一份，因此 Lua 字符串之间的相等性比较可以简化为其内部存储地址的比较。这意味着 Lua 字符串的相等性比较总是为 O(1). 而在其他编程语言中，字符串的相等性比较则通常为 O(n)，即需要逐个字节（ 或按若干个连续字节） 进行比较。</li><li>在使用“==”做等于判断时，要注意对于 table, userdata 和函数， Lua 是作引用比较的。也就是说，只有当两个变量引用同一个对象时，才认为它们相等。如实例：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123; x = <span class="number">1</span>, y = <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">local</span> b = &#123; x = <span class="number">1</span>, y = <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">if</span> a == b <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a==b"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a~=b"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">---output:</span></span><br><span class="line">a~=b</span><br></pre></td></tr></table></figure></li></ol><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><table><thead><tr><th>表达符</th><th>备注</th></tr></thead><tbody><tr><td>and</td><td>逻辑与</td></tr><tr><td>or</td><td>逻辑或</td></tr><tr><td>not</td><td>逻辑非</td></tr></tbody></table><p>Lua 中的 <code>and</code> 和 <code>or</code> 是不同于C/C++语言的。在C/C++语言中，<code>and</code> 和 <code>or</code> 只得到两个值 1 和 0，其中 1表示真，0 表示假。而 Lua 中 <code>and</code>和<code>or</code> 的执行结果返回的表达式的结果，而非<code>true</code>或者<code>flase</code>这类逻辑结果。也就是说：</p><ol><li><code>a and b</code> 如果 a 为 <code>nil</code>，则返回 a，否则返回 b;</li><li><code>a or b</code> 如果 a 为 <code>nil</code>，则返回 b，否则返回 a。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>local c = nil</span><br><span class="line"><span class="meta">&gt;</span>local d = 0</span><br><span class="line"><span class="meta">&gt;</span>local e = 100</span><br><span class="line"><span class="meta">&gt;</span>print(c and d)</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span>print(c and e)</span><br><span class="line">nil</span><br><span class="line"><span class="meta">&gt;</span>print(d and e)</span><br><span class="line">100</span><br><span class="line"><span class="meta">&gt;</span>print(c or d)</span><br><span class="line">0</span><br><span class="line"><span class="meta">&gt;</span>print(c or e)</span><br><span class="line">100</span><br><span class="line"><span class="meta">&gt;</span>print(not c)</span><br><span class="line">true</span><br><span class="line"><span class="meta">&gt;</span>print(not d)</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li></ol><p><strong>特别注意：</strong></p><ol><li>所有逻辑操作符将 false 和 nil 视作假，其他任何值视作真；</li><li>对于 and 和 or，“短路求值”；</li><li>对于 not，永远只返回 true 或者 false。</li></ol><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><table><thead><tr><th>优先级(由高到低)</th></tr></thead><tbody><tr><td>^</td></tr><tr><td>not   # -</td></tr><tr><td>*   /   %</td></tr><tr><td>+   -</td></tr><tr><td>..</td></tr><tr><td>&lt; &gt; &lt;=  &gt;=  ==  ~=</td></tr><tr><td>and</td></tr><tr><td>or</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> x, y = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">10</span></span><br><span class="line"><span class="keyword">local</span> res = <span class="number">0</span></span><br><span class="line">res = a + i &lt; b/<span class="number">2</span> + <span class="number">1</span> <span class="comment">--&gt;等价于res = (a + i) &lt; ((b/2) + 1)</span></span><br><span class="line">res = <span class="number">5</span> + x^<span class="number">2</span>*<span class="number">8</span> <span class="comment">--&gt;等价于res = 5 + ((x^2) * 8)</span></span><br><span class="line">res = a &lt; y <span class="keyword">and</span> y &lt;=x <span class="comment">--&gt;等价于res = (a &lt; y) and (y &lt;= x)</span></span><br></pre></td></tr></table></figure><p><strong>tips</strong></p><ol><li>若不确定某些操作符的优先级，就应显示地用括号来指定运算顺序。这样做还可以提高代码的可读性。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算术表达式&quot;&gt;&lt;a href=&quot;#算术表达式&quot; class=&quot;headerlink&quot; title=&quot;算术表达式&quot;&gt;&lt;/a&gt;算术表达式&lt;/h2&gt;&lt;p&gt;Lua 的算术运算符如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达符&lt;/th&gt;
&lt;th
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
      <category term="表达式" scheme="https://m.fanruo.net/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>2.2 lua 基础数据类型</title>
    <link href="https://m.fanruo.net/2019/05/19/2-2-lua-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://m.fanruo.net/2019/05/19/2-2-lua-基础数据类型/</id>
    <published>2019-05-19T15:39:48.000Z</published>
    <updated>2019-05-21T08:34:19.316Z</updated>
    
    <content type="html"><![CDATA[<p>lua 是一门极其精简的语言，内置类型只要<code>nil</code>,<code>boolean</code>,<code>number</code>等三种基本类型，以及<code>string</code>,<code>table</code>等二种组合类型。没有C/C++ 等语言中的<code>class</code>、<code>struct</code>等复杂类型，这些类型可以通过<code>table</code>来实现。同时，不同于其他语言（如C/C++和java），<code>function</code>在lua中也作为一个一级类型。</p><h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p><code>nil</code> 是一种类型，Lua 将 <code>nil</code> 用于表示“无效值”。</p><ol><li>一个变量在第一次赋值前的默认值是 <code>nil</code></li><li>将<code>nil</code> 赋予给一个全局变量就等同于删除它.</li><li>openresty 中提供了另一种表示空值的类型<code>ngx.null</code>.</li></ol><p><code>nil</code>在lua中有其特殊意义，如果一个变量被设置为<code>nil</code>，就等于说该变量<strong>未定义</strong>，与无穷无尽的其他未定义的变量一样。那么，如果把redis查询为空的结果设置为<code>nil</code>，就无法把”查询为空”和“未定义”区分开来了，例如在一个table中，一个key对应一个value，如果将该value设置为<code>nil</code>，则相当让key凭空消失，这显然是不合理的。所以必须用一个userdata类型的独特的值来表示这种查询为空，但又不等同于未定义的变量，例如<code>ngx.null</code>。同样的情况想必在sql的lua模块中也会出现，用来处理记录中键值查询为空的情况。<br>lua中神奇的<code>nil</code>了。<code>nil</code>是一种类型，该类型只有一个值，这个值就是<code>nil</code>。该值的作用只有一个，表示一个变量不存在。跟C\C++等常规语言不同，”不存在“跟空、0完全是两个概念。在C语言中，一个字符串如果为空，那么它就只有一个为<code>0</code>的<code>\nul</code>结束符，如果对齐进行逻辑判断，则是假。但lua中，只要一个变量不是<code>nil</code>类型或者是boolean类型中的<code>false</code>,则对它进行逻辑判断，结果是真，即使该值是一个数字0，或者是一个空字符串。</p><h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>布尔类型，可选值 true/false；<strong>Lua 中 nil 和 false 为“假”</strong>，其它所有值均为“真”。比如 0 和空字符串就是“真”；C 或者 Perl 程序员或许会对此感到惊讶。</p><h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>Number 类型用于表示实数，和 C/C++ 里面的 <code>double</code> 类型很类似。可以使用数学函数<code>math.floor</code>（ 向下取整） 和 <code>math.ceil</code>（ 向上取整） 进行取整操作。</p><p>一般地，Lua 的 number 类型就是用双精度浮点数来实现的。值得一提的是，LuaJIT 支持所谓的“dual-number”（ 双数） 模式，即 LuaJIT 会根据上下文用整型来存储整数，而用双精度浮点数来存放浮点数。另外，LuaJIT 还支持“长长整型”的大整数（ 在 x86_64 体系结构上则是 64 位整数） 。例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>print(9223372036854775807LL - 1)</span><br><span class="line">9223372036854775806LL</span><br></pre></td></tr></table></figure></p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>Lua 中有三种方式表示字符串:</p><ol><li>使用一对匹配的单引号。例：’hello’。</li><li>使用一对匹配的双引号。例：”hello”。</li><li>字符串还可以用一种长括号（ 即[[ ]]） 括起来的方式定义。我们把两个正的方括号（ 即[[）间插入 n 个等号定义为第 n 级正长括号。就是说，0 级正的长括号写作 [[ ，一级正的长括号写作 [=[，如此等等。反的长括号也作类似定义；举个例子，4 级反的长括号写作]====]。一个长字符串可以由任何一级的正的长括号开始，而由第一个碰到的同级反的长括号结束。整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。这种方式描述的字符串可以包含任何东西，当然本级别的反长括号除外。例：[[abc\nbc]]，里面的 “\n” 不会被转义。</li></ol><p><strong>特别注意：</strong>Lua 的字符串是<em>不可改变</em>的值，不能像在 c 语言中那样直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。Lua 也<em>不能</em>通过下标来访问字符串的某个字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>local str1 = 'hello world'</span><br><span class="line"><span class="meta">&gt;</span>local str2 = "hello world"</span><br><span class="line"><span class="meta">&gt;</span>local str3 = [["add\name",'hello']]</span><br><span class="line"><span class="meta">&gt;</span>local str4 = [=[string have a [[]].]=]</span><br><span class="line"><span class="meta">&gt;</span>local str5 = 'hello\nworld'</span><br><span class="line"><span class="meta">&gt;</span>local str6 = "hello\nworld"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>print(str1)</span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;</span>print(str2)</span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;</span>print(str3)</span><br><span class="line">"add\name",'hello'</span><br><span class="line"><span class="meta">&gt;</span>print(str4)</span><br><span class="line">string have a [[]]</span><br><span class="line"><span class="meta">&gt;</span>print(str5)</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"><span class="meta">&gt;</span>print(str6)</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong> 从上面实例<code>str5</code>和<code>str6</code>可以看出<code>&#39;</code>和<code>&quot;</code>在lua中作用是一致的，二者中的<code>\n</code>这类转义字符都会被转义，这一点要区别一下shell中<code>&#39;</code>和<code>&quot;</code>。</p><p>在 Lua 实现中，Lua 字符串一般都会经历一个“内化”（ intern） 的过程，即两个完全一样的Lua 字符串在 Lua 虚拟机中只会存储一份。每一个 Lua 字符串在创建时都会插入到 Lua 虚拟机内部的一个全局的哈希表中。 这意味着</p><ol><li>创建相同的 Lua 字符串并不会引入新的动态内存分配操作，所以相对便宜（ 但仍有全局哈希表查询的开销。</li><li>内容相同的 Lua 字符串不会占用多份存储空间。</li><li>已经创建好的 Lua 字符串之间进行相等性比较时是 O(1) 时间度的开销，而不是通常见到的 O(n)，比较索引就可以了。</li></ol><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是字符串（ string） 或者 number 类型，但也可以是除 nil 以外的任意类型的值。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> corp = &#123;</span><br><span class="line">web = <span class="string">"www.google.com"</span>, <span class="comment">--索引为字符串，key = "web",</span></span><br><span class="line"><span class="comment">-- value = "www.google.com"</span></span><br><span class="line">telephone = <span class="string">"12345678"</span>, <span class="comment">--索引为字符串</span></span><br><span class="line">staff = &#123;<span class="string">"Jack"</span>, <span class="string">"Scott"</span>, <span class="string">"Gary"</span>&#125;, <span class="comment">--索引为字符串，值也是一个表</span></span><br><span class="line"><span class="number">100876</span>, <span class="comment">--相当于 [1] = 100876，此时索引为数字</span></span><br><span class="line"><span class="comment">-- key = 1, value = 100876</span></span><br><span class="line"><span class="number">100191</span>, <span class="comment">--相当于 [2] = 100191，此时索引为数字</span></span><br><span class="line">[<span class="number">10</span>] = <span class="number">360</span>, <span class="comment">--直接把数字索引给出</span></span><br><span class="line">[<span class="string">"city"</span>] = <span class="string">"Beijing"</span> <span class="comment">--索引为字符串</span></span><br><span class="line">&#125; p</span><br><span class="line">rint(corp.web) <span class="comment">--&gt;output:www.google.com</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="string">"telephone"</span>]) <span class="comment">--&gt;output:12345678</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="number">2</span>]) <span class="comment">--&gt;output:100191</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="string">"city"</span>]) <span class="comment">--&gt;output:"Beijing"</span></span><br><span class="line"><span class="built_in">print</span>(corp.staff[<span class="number">1</span>]) <span class="comment">--&gt;output:Jack</span></span><br><span class="line"><span class="built_in">print</span>(corp[<span class="number">10</span>]) <span class="comment">--&gt;output:360</span></span><br></pre></td></tr></table></figure></p><p>在内部实现上，table 通常实现为一个哈希表、一个数组、或者两者的混合。具体的实现为何种形式，动态依赖于具体的 table 的键分布特点。</p><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>在 Lua 中，函数:</p><ol><li>也是一种数据类型,</li><li>函数可以存储在变量中，</li><li>可以通过参数传递给其他函数，</li><li>还可以作为其他函数的返回值</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"in the function"</span>)</span><br><span class="line"><span class="comment">--dosomething()</span></span><br><span class="line"><span class="keyword">local</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">local</span> y = <span class="number">20</span></span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> a = foo <span class="comment">--把函数赋给变量</span></span><br><span class="line"><span class="built_in">print</span>(a())</span><br><span class="line"><span class="comment">--output:</span></span><br><span class="line"><span class="keyword">in</span> the <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">30</span></span><br></pre></td></tr></table></figure><p>有名函数的定义可以理解为是匿名函数对变量的赋值。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>可以写成如下形式：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>类似地，<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;lua 是一门极其精简的语言，内置类型只要&lt;code&gt;nil&lt;/code&gt;,&lt;code&gt;boolean&lt;/code&gt;,&lt;code&gt;number&lt;/code&gt;等三种基本类型，以及&lt;code&gt;string&lt;/code&gt;,&lt;code&gt;table&lt;/code&gt;等二种组合类型。没有C
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>2.1 lua 基本语法</title>
    <link href="https://m.fanruo.net/2019/05/19/2-1-lua-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://m.fanruo.net/2019/05/19/2-1-lua-基本语法/</id>
    <published>2019-05-19T15:35:04.000Z</published>
    <updated>2019-05-21T08:33:41.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>C语言之后大多数讲解语言的书籍都会以打印<code>hello world</code>来开始。那么，如何使用lua 打印<code>hello world</code>呢？</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>和python、golang等语言类似，执行这条语句有两种方式：</p><ol><li>交互方式尴尬</li><li>执行lua脚本文件的方式</li></ol><h3 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h3><p>首先，在终端输入<code>lua</code>，进入交互模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[work@fanruo ~]$ lua</span><br><span class="line">Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure><p>输入<code>lua</code>后会显示一行信息，包括版本、版权信息等，随后是提示符。在提示符后输入<code>print(&quot;hello world&quot;)</code> 回车，就会打印<code>hello world</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> print("hello world")</span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行lua脚本文件方式"><a href="#执行lua脚本文件方式" class="headerlink" title="执行lua脚本文件方式"></a>执行lua脚本文件方式</h3><p>将上述语句保存为<code>hello_world.lua</code>文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/lua</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>在命令输入如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@fanruo ~]$ lua hello_world.lua</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><p>单行注释</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br><span class="line"><span class="comment">--单行注释</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多</span></span><br><span class="line"><span class="comment">行</span></span><br><span class="line"><span class="comment">注</span></span><br><span class="line"><span class="comment">释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure></li></ol><p><code>lua</code>的多行注释有点像<code>html</code>的多行注释。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><code>lua</code>的标识符和<code>c/c++</code>等语言类似：</p><ol><li>以下划线（_）和字母（a-zA-Z）开头；</li><li>后续加0个或者多个下划线(_)、字母（a-zA-Z）和数字（0-9）；</li><li>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。</li><li>不允许使用特殊字符如 @, $, 和 % 来定义标示符；</li><li>Lua 是一个区分大小写的编程语言。</li></ol><p><strong>注意：</strong>事实上，在编程时，即使使用的语言区分大小写也不建议使用大小写来区分标识符。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="keyword">break</span> <span class="keyword">do</span> <span class="keyword">else</span> <span class="keyword">elseif</span></span><br><span class="line"><span class="keyword">end</span> <span class="literal">false</span> <span class="keyword">for</span> <span class="function"><span class="keyword">function</span> <span class="title">if</span></span></span><br><span class="line"><span class="function"><span class="title">in</span> <span class="title">local</span> <span class="title">nil</span> <span class="title">not</span> <span class="title">or</span></span></span><br><span class="line"><span class="function"><span class="title">repeat</span> <span class="title">return</span> <span class="title">then</span> <span class="title">true</span> <span class="title">until</span></span></span><br><span class="line"><span class="function"><span class="title">while</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;C语言之后大多数讲解语言的书籍都会以打印&lt;code&gt;hello world&lt;/code&gt;来开始。那么，如何使用lua 打印&lt;code&gt;hel
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>1.2 lua 环境安装</title>
    <link href="https://m.fanruo.net/2018/09/14/1-2-lua-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://m.fanruo.net/2018/09/14/1-2-lua-环境安装/</id>
    <published>2018-09-14T12:40:04.000Z</published>
    <updated>2019-05-21T08:33:10.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lua-环境安装"><a href="#lua-环境安装" class="headerlink" title="lua 环境安装"></a>lua 环境安装</h1><h2 id="linux-系统安装lua"><a href="#linux-系统安装lua" class="headerlink" title="linux 系统安装lua"></a>linux 系统安装lua</h2><p>linux &amp; Mac上安装 Lua 安装非常简单，只需要下载源码包并在终端解压编译即可，本文使用了5.3.4版本进行安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.4.tar.gz</span><br><span class="line">tar zxf lua-5.3.4.tar.gz</span><br><span class="line">cd lua-5.3.4</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><h2 id="mac-系统安装lua"><a href="#mac-系统安装lua" class="headerlink" title="mac 系统安装lua"></a>mac 系统安装lua</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.4.tar.gz</span><br><span class="line">tar zxf lua-5.3.4.tar.gz</span><br><span class="line">cd lua-5.3.4</span><br><span class="line">make macosx test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lua-环境安装&quot;&gt;&lt;a href=&quot;#lua-环境安装&quot; class=&quot;headerlink&quot; title=&quot;lua 环境安装&quot;&gt;&lt;/a&gt;lua 环境安装&lt;/h1&gt;&lt;h2 id=&quot;linux-系统安装lua&quot;&gt;&lt;a href=&quot;#linux-系统安装lua&quot; c
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>1.1 lua 简介</title>
    <link href="https://m.fanruo.net/2018/09/14/1-1-lua-%E7%AE%80%E4%BB%8B/"/>
    <id>https://m.fanruo.net/2018/09/14/1-1-lua-简介/</id>
    <published>2018-09-14T12:32:38.000Z</published>
    <updated>2019-05-21T08:32:23.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Lua（发音： /ˈluːə/）程序设计语言是一个简洁、轻量、可扩展的脚本语言，Lua在葡萄牙语中的意思是月亮。<br>Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。</p><p>Lua是一种轻量语言，它的官方版本只包括一个精简的核心和最基本的库。这使得Lua体积小、启动速度快。它用ANSI C 语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。和许多“大而全”的语言不一样，网路通讯、图形界面等都没有默认提供。但是Lua可以很容易地被扩展：由宿主语言（通常是C或C++）提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。事实上，现在已经有很多成熟的扩展模块可供选用。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>Lua的目标是成为一个很容易嵌入其它语言中使用的语言。大多数程序员也认为它的确做到了这一点。</li><li>很多应用程序使用Lua作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li><strong>轻量级：</strong> 它是使用ANSI C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。它的官方版本只包括一个精简的核心和最基本的库。这使得Lua体积小、启动速度快。和许多“大而全”的语言不一样，网路通讯、图形界面等都没有默认提供。但是Lua可以很容易地被扩展：由宿主语言（通常是C或C++）提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。事实上，现在已经有很多成熟的扩展模块可供选用。</li><li><strong>可扩展：</strong> Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li><li><strong>支持多重编程范式：</strong> 支持面向过程(procedure-oriented)编程和函数式编程(functional programming)。</li><li><strong>自动内存管理：</strong> 支持增量式垃圾收集策略。</li><li><strong>原生数据类型少：</strong> 它只提供了数字（缺省是双精度浮点数，可配置）、布尔量、字符串、表、子程序、协程（coroutine）以及用户自定义数据这几种。但是其处理表和字符串的效率非常之高，加上元表的支持，开发者可以高效的模拟出需要的复杂数据类型（比如数组，哈希表，集合，对象等）。</li><li><strong>可以用于嵌入式硬件:</strong> 不仅可以嵌入其他编程语言，而且可以嵌入微处理器中.</li><li><strong>支持协程：</strong> 有内建的，与操作系统无关的协作式多线程（coroutine）支持。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>游戏开发</li><li>独立应用脚本</li><li>Web 应用脚本</li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li></ol><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>lua 打印<code>hello workd</code>只需调用<code>print()</code>函数即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Lua（发音： /ˈluːə/）程序设计语言是一个简洁、轻量、可扩展的脚本语言，Lua在葡萄牙语中的意思是月亮。&lt;br&gt;Lua 是巴西里约热
      
    
    </summary>
    
      <category term="语言" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="lua" scheme="https://m.fanruo.net/categories/%E8%AF%AD%E8%A8%80/lua/"/>
    
    
      <category term="lua" scheme="https://m.fanruo.net/tags/lua/"/>
    
  </entry>
  
</feed>
