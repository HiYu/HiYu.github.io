<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡 若</title>
  
  <subtitle>初心 读书 知新 生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m.fanruo.net/"/>
  <updated>2020-02-28T14:34:20.912Z</updated>
  <id>https://m.fanruo.net/</id>
  
  <author>
    <name>Frank Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【leetcode】19. 栈&amp;队列-队列的最大值</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9119-%E6%A0%88-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】19-栈-队列-队列的最大值/</id>
    <published>2020-02-28T14:33:41.000Z</published>
    <updated>2020-02-28T14:34:20.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br>难易程度:<strong>Medium</strong></p><p><strong>示例 1</strong>：</p><blockquote><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题和<strong>包含min函数的栈</strong>有点类似，但是要复杂很多。因为栈是在列表的异端操作，在<code>push</code>和<code>pop</code>操作时能够决定当前栈的最大值最小值。而队列<code>pop</code>和<code>back</code>操作是在列表的两端操作，因此队列在不同状态下的最值是变动的。</p><p>设有队列：<code>[8,3,5,4,1,2]</code><br>则最大值队列：<code>[8,5,4,2]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 0; max = 8; [8]</span><br><span class="line">i = 1; max = 5; [8,5]</span><br><span class="line">i = 2; max = 5; [8,5]</span><br><span class="line">i = 3; max = 4; [8,5,4]</span><br><span class="line">i = 4; max = 2; [8,5,4,2]</span><br><span class="line">i = 5; max = 2; [8,5,4,2]</span><br></pre></td></tr></table></figure><p>假设上述队列中加入新元素<code>9</code>,则最大值对列：<code>[9]</code><br>也即，队列中每个位置<code>i</code>的对应最大值<code>max</code>是索引区间<code>[i, n]</code>之间的最大值，因此，最大值队列是一个单调递减队列。因此，当有元素入队列的时候，需要逆序遍历更新最大值队列。</p><p>说明：1 &lt;= value &lt;= 10^5也算是常数时间了和队列长度，操作次数无关。</p><p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; max;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line">        q = <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        max = <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!max.empty() &amp;&amp; value &gt; max.back()) &#123;</span><br><span class="line">            max.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        max.push_back(value);</span><br><span class="line">        q.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (res == max.front()) &#123;</span><br><span class="line">            max.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="队列" scheme="https://m.fanruo.net/categories/leetcode/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="队列" scheme="https://m.fanruo.net/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】18.栈&amp;队列-用两个栈实现队列</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9118-%E6%A0%88-%E9%98%9F%E5%88%97-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】18-栈-队列-用两个栈实现队列/</id>
    <published>2020-02-28T14:32:18.000Z</published>
    <updated>2020-02-28T14:34:23.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p></blockquote><p><strong>提示</strong>：</p><blockquote><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先明确，<strong>栈</strong>的特点是<strong>先进后出</strong>；<strong>队列</strong>的特点是<strong>先进先出</strong>。<br>要想用栈实现队列的特性，必须将最先进入的元素放在栈顶、最后放入的元素放在栈低。如何操作呢？题中给出的是<strong>两个栈实现一个队列</strong>，这时候，我们就需要利用另外一个栈了，假设我们有两个栈<code>stack1</code>和<code>stack2</code>，设<code>stack1</code>为操作栈，<code>stack2</code>为辅助栈。将一个元素加入到<code>stack1</code>中，我们可以借助<code>stack2</code>：</p><ol><li>如果<code>stack1</code>为空，则直接将元素<code>value</code> <code>push</code>到<code>stack1</code>中，这时<code>stack1</code>栈顶&amp;栈低是同一个元素</li><li>如果<code>stack1</code>不为空，则将<code>stack1</code>中的元素一次<code>push</code>到<code>stack2</code>中，此时，<code>stack1</code>为空，新元素<code>value</code> <code>push</code>到<code>stack1</code>中</li><li>将<code>stack2</code>中的元素写回<code>stack1</code>, <code>stack2</code>此次写入辅助使命完成。</li></ol><p>上面描述了写入流程，那么读取呢？更简单，直接正常操作<code>stack1</code>即可。</p><p>另外，可以维护一个队列长度变量<code>len</code>可以<code>O(1)</code>时间获取队列长度用于判断队列是否为空。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        stack1 = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        stack2 = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            stack1.push(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack1.push(value);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                stack1.push(stack2.top());</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/categories/leetcode/%E6%A0%88/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://m.fanruo.net/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】17. 栈&amp;队列-包含min函数的栈</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9117-%E6%A0%88-%E9%98%9F%E5%88%97-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】17-栈-队列-包含min函数的栈/</id>
    <published>2020-02-28T14:30:54.000Z</published>
    <updated>2020-02-28T14:34:26.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(<span class="number">-3</span>);</span><br><span class="line">minStack.min();  <span class="comment">// --&gt; 返回 -3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    <span class="comment">//  --&gt; 返回 0.</span></span><br><span class="line">minStack.min();   <span class="comment">//--&gt; 返回 -2.</span></span><br></pre></td></tr></table></figure><p><strong>提示</strong>：</p><blockquote><p>各函数的调用总次数不超过 20000 次</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于队列有<code>先进先出</code>特性，对于队列<code>s</code>来说每次<code>push</code>或者<code>pop</code>一个元素都可能改变栈<code>s</code>的最小值<code>m</code>。</p><ol><li><code>push</code>一个元素<code>x</code>，如果<code>x &lt; m</code>, 则将<code>m</code>先入栈以保留当前栈的最小值，同时<code>m = x</code></li><li><code>push</code>新元素<code>x</code>入队列</li><li>当<code>pop</code>一个元素时，首先判断<code>s.top() == m</code>，如果成立，按照步骤1、2说明下一个元素是专门存的最小元素，需要同时<code>pop</code>出来</li><li>否则，直接<code>pop</code>就行</li><li><code>top</code>时正常<code>top</code>就行</li></ol><p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        s = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        m = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">            s.push(m);<span class="comment">// 保存插入前的最小值</span></span><br><span class="line">            m = x;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.top() == m) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            m = s.top();<span class="comment">// 取出pop后的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">         s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/categories/leetcode/%E6%A0%88/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】16. 字符串-翻转单词顺序</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9116-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】16-字符串-翻转单词顺序/</id>
    <published>2020-02-28T14:30:11.000Z</published>
    <updated>2020-02-28T14:34:28.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入: “the sky is blue”<br>输出: “blue is sky the”</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></blockquote><p><strong>示例 3</strong>：</p><blockquote><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p><strong>说明</strong>：</p><blockquote><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题最直观的做法就是遍历整个字符串<code>s</code>，切出每个单词，然后<code>头插法</code>将切出的单词拼接为一个新的字符串。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; size) &#123;</span><br><span class="line">            <span class="keyword">while</span> (s[cur] == <span class="string">' '</span>) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = cur;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; size &amp;&amp; s[cur] != <span class="string">' '</span>) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = cur - start;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 拼接为新的字符串</span></span><br><span class="line">                res = s.substr(start, len) + <span class="string">" "</span> + res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理多余的空格</span></span><br><span class="line">        res.erase(res.end() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a stu
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】15. 字符串-把字符串转换成整数</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9115-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】15-字符串-把字符串转换成整数/</id>
    <published>2020-02-28T14:29:32.000Z</published>
    <updated>2020-03-01T12:30:10.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。<br>难易程度:<strong>Medium</strong></p><p><strong>说明</strong>：</p><blockquote><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p></blockquote><p><strong>示例 1</strong>:</p><blockquote><p>输入: “42”<br>输出: 42</p></blockquote><p><strong>示例 2</strong>:</p><blockquote><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p></blockquote><p><strong>示例 3</strong>:</p><blockquote><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p></blockquote><p><strong>示例 4</strong>:</p><blockquote><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。</p></blockquote><p><strong>示例 5</strong>:</p><blockquote><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。因此返回 INT_MIN (−231) 。</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题并不难，循环处理每一个字符：</p><ol><li>如果是空白则跳过，直到找到第一个非空白字符；</li><li>如果第一个非空白字符为<code>-</code>则<code>sign = -1</code>；</li><li>如果第一个非空白字符为<code>+</code>则<code>sign = 1</code>；</li><li>如果第一个非空白字符不是<code>[\-+0-9]</code>则<code>return 0</code>；</li><li>遍历数字部分（ <code>res = res * 10 + (str[begin] - &#39;0&#39;)</code>），注意此处需要判断是否溢出（<code>res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; str[begin] &gt; &#39;7&#39;)</code>）；</li><li>如果溢出则返回最大（小）值；</li><li>返回最终结果：<code>return  res * sign;</code></li></ol><p>关键在于处理细节：</p><ol><li>符号</li><li>前导零、前导空白</li><li>数字结束处理</li><li>大数处理</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 处理前导空白</span></span><br><span class="line">        <span class="keyword">while</span> (str[begin] == <span class="string">' '</span>) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理正负号</span></span><br><span class="line">        <span class="keyword">if</span> (str[begin] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[begin] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[begin] &lt; <span class="string">'0'</span> &amp;&amp; str[begin] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; str.size() &amp;&amp; str[begin] &gt;= <span class="string">'0'</span> &amp;&amp; str[begin] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理大数</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; str[begin] &gt; <span class="string">'7'</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数值处理，整道题这行是核心</span></span><br><span class="line">            res = res * <span class="number">10</span> + (str[begin] - <span class="string">'0'</span>);</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理符号</span></span><br><span class="line">        <span class="keyword">return</span>  res * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。&lt;br&gt;首先，该函数会根据需要丢弃无
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】14. 字符串- 左旋转字符串</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9114-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】14-字符串-左旋转字符串/</id>
    <published>2020-02-28T14:28:29.000Z</published>
    <updated>2020-02-28T14:34:37.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>1 &lt;= k &lt; s.length &lt;= 10000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题可以将字符串<code>s</code>中的<code>n-&gt;0, n+1-&gt;1, ..., (n + i) % len-&gt;i</code>，即<code>res[i] = s[(n + i) % len]</code>。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            res.append(<span class="number">1</span>,s[(n + i++) % len]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>相对于方法一，需要遍历整个<code>s</code>,一个更简单的方法就是将旋转看做将字符串<code>s</code>的后<code>s.size() - n</code>个字符组成的子串<code>substr2</code>和前<code>n</code>个字符组成的子串<code>substr1</code>拼接为一个新的字符串串。<br><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substr(n, s.size() - n) + s.substr(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】13. 数组-滑动窗口的最大值</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9113-%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】13-数组-滑动窗口的最大值/</id>
    <published>2020-02-28T14:27:16.000Z</published>
    <updated>2020-02-28T14:34:40.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><blockquote><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p></blockquote><blockquote><p>  滑动窗口的位置                最大值<br>[1  3  -1] -3  5  3  6  7      3<br>1 [3  -1  -3] 5  3  6  7       3<br>1  3 [-1  -3  5] 3  6  7       5<br>1  3  -1 [-3  5  3] 6  7       5<br>1  3  -1  -3 [5  3  6] 7       6<br>1  3  -1  -3  5 [3  6  7]      7</p></blockquote><p><strong>提示</strong>：</p><blockquote><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过分析，索引<code>[i - k, i)</code>之间的<code>k</code>个元素的最大值<code>max</code>的索引<code>max_index</code>存在<code>max_index &gt; i - k &amp;&amp; max_index &lt; i</code>且<code>nums[i] &gt;= nums[max_index]</code></p><ol><li>则<code>max_index = i</code>,即<code>i</code>是<code>(i - k, i]</code>之间元素最大值的<code>max_index</code></li><li>否则遍历<code>(i - k, i]</code>之间所有元素找到最大值<code>max</code>及<code>max_index</code></li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_index &gt; i - k &amp;&amp; max_index &lt; i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt;= nums[max_index]) &#123;</span><br><span class="line">                    max_index = i; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max_index = i - k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = max_index; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt;= nums[max_index]) &#123;</span><br><span class="line">                        max_index = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(nums[max_index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。&lt;br&gt;&lt;strong&gt;难易程度&lt;/strong&gt;：easy&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】12. 数组-0～n-1中缺失的数字</title>
    <link href="https://m.fanruo.net/2020/02/24/%E3%80%90leetcode%E3%80%9112-%E6%95%B0%E7%BB%84-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/02/24/【leetcode】12-数组-0～n-1中缺失的数字/</id>
    <published>2020-02-24T12:36:56.000Z</published>
    <updated>2020-02-24T12:38:54.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>:</p><blockquote><p>输入: [0,1,3]<br>输出: 2</p></blockquote><p><strong>示例 2</strong>:</p><blockquote><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>1 &lt;= 数组长度 &lt;= 10000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从本题题意可以提出如下几个关键信息：</p><ol><li>数组长度为<code>n-1</code></li><li>每个数字都在范围<code>0～n-1</code>之内(一个<code>n</code>个元素)</li><li>数组是递增有序，且唯一</li></ol><p>跟进上面提取出的题意，可以得到信息：</p><ol><li>如果不缺数字的话，数字<code>i = nums[i]</code></li><li>当<code>i</code>位置的元素不是<code>i</code>,即<code>i != nums[i]</code>的时候，则有<code>j &gt; i; nums[j] &gt; j</code> 且<code>k &lt; i; nums[k] == k</code></li></ol><p>本题依旧是二分查找问题，只是调整范围的判断条件有所调整。</p><p><strong>时间复杂度</strong>：O(logN)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】11. 数组-在排序数组中查找数字</title>
    <link href="https://m.fanruo.net/2020/02/24/%E3%80%90leetcode%E3%80%9111-%E6%95%B0%E7%BB%84-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/02/24/【leetcode】11-数组-在排序数组中查找数字/</id>
    <published>2020-02-24T12:36:39.000Z</published>
    <updated>2020-02-24T12:37:27.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>统计一个数字在排序数组中出现的次数。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2</p></blockquote><p><strong>示例 2</strong>:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>0 &lt;= 数组长度 &lt;= 50000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题是一个典型的查找问题。根据题意可以提取两点信息：</p><ol><li>数组本身是有序的</li><li>需要输出<code>target</code>出现的次数</li></ol><p>因此，本题转换成查找边界问题：</p><ol><li><code>target</code>第一次出现的位置</li><li><code>target</code>最后一次出现的位置</li></ol><p><strong>时间复杂度</strong>：O(logN)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找target第一次出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123; </span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">// 保证nums[left]始终小于target</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == nums.size() ||right &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> start = left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找target最后一次出现的位置的下一个位置</span></span><br><span class="line">        right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 保证nums[left]最终是target最后一次出现的下一个位置或者数组的尾的下一个位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left - start;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;br&gt;&lt;strong&gt;难易程度&lt;/strong&gt;：easy&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】10. 数组-顺时针打印矩阵</title>
    <link href="https://m.fanruo.net/2020/02/24/%E3%80%90leetcode%E3%80%9110-%E6%95%B0%E7%BB%84-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>https://m.fanruo.net/2020/02/24/【leetcode】10-数组-顺时针打印矩阵/</id>
    <published>2020-02-24T10:45:11.000Z</published>
    <updated>2020-02-24T12:37:45.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题本质上一个模拟过程,设矩阵上右下左的范围一次是<code>top = 0,right = n - 1,button = m - 1,left = 0</code>：</p><ol><li><code>left-&gt;right</code>：上侧从左到右，<code>i = left; lmatrix[top][i]; i++</code>，遍历完后<code>top</code>这一行需要丢弃，<code>top++</code></li><li><code>top-&gt;button</code>：右侧从上到下，<code>i = top; matrix[i][right]; i++</code>，遍历完后<code>right</code>这一列需要丢弃，<code>right--</code></li><li><code>right-&gt;left</code>：下侧从右到左，<code>i = right; matrix[button][i]; i--</code>，遍历完后<code>button</code>这一行需要丢弃，<code>button--</code></li><li><code>button-&gt;top</code>：左侧从下到上，<code>i = button; matrix[i][left]; i++</code>，遍历完后<code>left</code>这一列需要丢弃，<code>left++</code></li></ol><p><strong>时间复杂度</strong>：O(N^2)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, button = m - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++top &gt; button) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= button; i++) &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) bareak;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--) &#123;</span><br><span class="line">                res.push_back(matrix[button][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--button &lt; top) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = button; i &gt;= top; i--) &#123;</span><br><span class="line">                res.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;br&gt;&lt;strong&gt;难易程度&lt;/strong&gt;：easy&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】9. 数组-二维数组中的查找</title>
    <link href="https://m.fanruo.net/2020/02/22/%E3%80%90leetcode%E3%80%919-%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://m.fanruo.net/2020/02/22/【leetcode】9-数组-二维数组中的查找/</id>
    <published>2020-02-22T15:10:42.000Z</published>
    <updated>2020-02-22T15:11:16.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><blockquote><p>现有矩阵 matrix 如下：<br>[<br> [1,   4,  7, 11, 15],<br> [2,   5,  8, 12, 19],<br> [3,   6,  9, 16, 22],<br> [10, 13, 14, 17, 24],<br> [18, 21, 23, 26, 30]<br>]</p></blockquote><blockquote><p>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题抓住两个点：</p><ol><li>每一行都按照从左到右递增的顺序排序</li><li>每一列都按照从上到下递增的顺序排序</li></ol><p>以上两点说明：</p><ol><li>矩阵<code>matrix</code>中小于<code>matrix[i][j]</code>的元素只能出现在该元素所在列的左侧或者上侧，即列坐标小于<code>j</code>或者行坐标小于<code>i</code></li><li>矩阵<code>matrix</code>中大于<code>matrix[i][j]</code>的元素只能出现在该元素所在列的右侧或者下侧，即列坐标大于<code>j</code>或者行坐标大于<code>i</code></li></ol><p>我们从右上角开始遍历：</p><ol><li><code>matrix[i][j] == target</code>,返回 true</li><li><code>matrix[i][j] &gt; target</code>, 由<strong>说明1</strong>可知<code>target</code>只可能出现在左侧（<code>matrix[i][j]</code>右&amp;上侧的数据已经遍历过了），则<code>i++</code></li><li><code>matrix[i][j] &lt; target</code>, 由<strong>说明2</strong>可知<code>target</code>只可能出现在下侧（<code>matrix[i][j]</code>右&amp;上侧的数据已经遍历过了），则<code>j--</code></li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】8. 数组-数组中重复的数字</title>
    <link href="https://m.fanruo.net/2020/02/22/%E3%80%90leetcode%E3%80%918-%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/02/22/【leetcode】8-数组-数组中重复的数字/</id>
    <published>2020-02-22T15:09:39.000Z</published>
    <updated>2020-02-22T15:10:22.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>2 &lt;= n &lt;= 100000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题解法很多。注意两点：</p><ol><li>查找：想到随机查找（数组下标、关联容器key）</li><li>所有数字都在 0～n-1 的范围内：可以利用数据下标</li><li>找出数组中任意一个重复的数字</li></ol><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以再遍历数组的同时对每一个元素做一个标记，这个标记是可以在O(1)时间复杂度获取的，继续遍历数组，并判断元素标记，如果已经存在，则直接返回，否则改变标志。具体流程如下：</p><ol><li>创建一个<code>map&lt;int, bool&gt; ret</code></li><li>遍历数组<code>nums</code>,如果<code>ret[nums[i]]</code> 不存在，则<code>ret[nums[i]] = true</code>；如果<code>ret[nums[i]] = true</code>，则返回<code>nums[i]</code></li></ol><p><strong>tips</strong>：步骤1种使用<code>map</code>并不是最优的,也可以使用<code>set</code>。在数组元素重复的比较少的时候可以使用<code>vector</code>。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; ret;<span class="comment">// 使用map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret.count(nums[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                ret[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret(nums.size(), <span class="literal">false</span>);<span class="comment">// 使用vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret[nums[i]] == <span class="literal">false</span>) &#123;</span><br><span class="line">                ret[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ret;<span class="comment">// 使用set</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ret.insert(nums[i]).second) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题并没限制不能改变原有数组<code>nums</code>，同时强调，所有数字都在 0～n-1 的范围内。因此，可以将元素<code>nums[i]</code>移动到<code>nums[nums[i]]</code>：</p><ol><li>当<code>nums[i] == i</code>,说明<code>i</code>位置上的元素已经是<code>i</code>了，不做任何处理，继续遍历</li><li>当<code>nums[i] == nums[nums[i]]</code>，说明<code>nums[i]</code>位置的元素已经是<code>nums[i]</code>,说明重复了，返回<code>nums[i]</code>即可</li><li>当上述两个条件都不满足的时候，交换一下</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i ) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[nums[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                nums[tmp] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;找出数组中重复的数字。&lt;br&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【好书推荐】血疫-埃博拉的故事</title>
    <link href="https://m.fanruo.net/2020/02/21/%E3%80%90%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90%E3%80%91%E8%A1%80%E7%96%AB-%E5%9F%83%E5%8D%9A%E6%8B%89%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>https://m.fanruo.net/2020/02/21/【好书推荐】血疫-埃博拉的故事/</id>
    <published>2020-02-21T02:02:31.000Z</published>
    <updated>2020-02-24T01:44:41.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/%E8%A1%80%E7%96%AB.png" alt="image"><br>这是一本“人命关天”的书。<br>艾滋病、SARS、埃博拉、寨卡，文明与病毒之间，只隔了一个航班的距离。<br>来自热带雨林的危险病毒，可在24小时内乘飞机抵达地球上的任何城市。航空线路连接了全世界的所有城市，构成网络。埃博拉已经进入网络，开始环球旅行。<br>这不只是一个病毒的故事，它关系着人类的无知、贪婪、勇气和牺牲，以及面对大自然时的敬畏。<br>真实，远比想象更惊悚。</p><p>普雷斯顿采访1967-1993年间大量埃博拉病毒亲历者，再现人类历史上病毒灾难来袭的真实场景。<br>1989年11月，美国弗吉尼亚州的雷斯顿城发生过埃博拉病毒事件。这个小城位于华盛顿特区以西24公里处，晴朗的天气里人们都能在雷斯顿城的高层建筑上望见华盛顿纪念碑那米黄色的尖顶。这里的灵长类动物检疫中心接收了100只从菲律宾进口的食蟹猴。没过几天，两只死亡。<br>理论上，少量动物死亡是很常见的。令人不安的是，不到一个月，又有29只猴子死亡。随着猴子死亡相继增加，科研人员渐渐逼近真相：猴子感染了一种未知的病毒。在大量研究下，他们认为这是埃博拉病毒。最后，美军出动将大楼封锁，所有动物处死。幸运的是，在目前已知的五种埃博拉病毒中，这种雷斯顿型亚型只感染灵长类动物，让人类逃过一劫。<br>1994年，美国作家理查德.普雷斯顿基于这一史料，采访大量亲历者后出版非虚构作品。</p><h1 id="总结-amp-拓展"><a href="#总结-amp-拓展" class="headerlink" title="总结&amp;拓展"></a>总结&amp;拓展</h1><p>全书介绍了<code>丝状病毒</code>的几种比较早期的病毒发现爆发的过程。<code>丝状病毒</code>包含的属有：</p><ol><li>马尔堡病毒</li><li>埃博拉病毒</li></ol><p>其中埃博拉病毒包括：</p><ol><li>Zaire ebolavirus（EBOV） (扎伊尔埃博拉病毒, 1976）- 标准亚种 （致死率高达90%）</li><li>Sudan ebolavirus（SUDV） (苏丹埃博拉病毒, 1976） （致死率高达68%）</li><li>Reston ebolavirus（RESTV） (雷斯顿埃博拉病毒, 1989）（所有感染者都为猴类，无人类感染）</li><li>Taï Forest ebolavirus（TAFV） (科特迪瓦埃博拉病毒, 1994）</li><li>Bundibugyo ebolavirus（BDBV） (本迪布焦埃博拉病毒, 2007）</li><li>Bombali ebolavirus（BOMV） (邦巴利埃博拉病毒, 2018）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://q66nxrlmf.bkt.clouddn.com/%E8%A1%80%E7%96%AB.png&quot; alt
      
    
    </summary>
    
      <category term="书籍推荐" scheme="https://m.fanruo.net/categories/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="埃博拉" scheme="https://m.fanruo.net/tags/%E5%9F%83%E5%8D%9A%E6%8B%89/"/>
    
      <category term="丝状病毒" scheme="https://m.fanruo.net/tags/%E4%B8%9D%E7%8A%B6%E7%97%85%E6%AF%92/"/>
    
      <category term="马尔堡" scheme="https://m.fanruo.net/tags/%E9%A9%AC%E5%B0%94%E5%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】7. 数组-移除元素</title>
    <link href="https://m.fanruo.net/2020/02/19/%E3%80%90leetcode%E3%80%917-%E6%95%B0%E7%BB%84-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>https://m.fanruo.net/2020/02/19/【leetcode】7-数组-移除元素/</id>
    <published>2020-02-19T15:59:06.000Z</published>
    <updated>2020-02-24T10:45:54.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1</strong>:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 2</strong>:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明</strong>:</p><p>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。<br>本题依旧是双指针问题，下标<code>l</code>是新数组的尾后位置，遍历数组<code>nums</code>，当元素<code>nums[i]!=val</code>时，将<code>nums[i]</code>追加到新数组尾部。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nums.size(); r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] != val) &#123;</span><br><span class="line">                nums[l++] = nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>注意，方法一中，虽然时间复杂度是O(N)，但是，当需要删除的数据很少的时候，会做很多不必要的复制赋值操作，假设数组总共有<code>n</code>个元素，和 <code>l</code>,<code>i</code>至少遍历<code>2n</code>步。例如数组<code>nums[] = [1,2,3,4,5]; val = 5</code>，遍历过程种会执行<code>nums[0] = nums[0], ... nums[3] = nums[3]</code>等一系列不必要的操作。</p><p>我们注意到题目中提到<code>元素的顺序可以改变</code>,这是在提示我们，除了<code>解法一</code>还有其他方法，而且元素的顺序是改变了的：<br>当遇到<code>nums[l] = val</code>时，可以将当前元素与最后一个元素<code>nums[r]</code>进行交换，并释放最后一个元素。这实际上使数组的大小减少了1。<br>请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[l] == val) &#123;</span><br><span class="line">               nums[l] = nums[r];<span class="comment">//这里nums[r]的值已经存放在nums[r]，原nums[l]数据本来就是要删除的，因此不需要完全交换两个元素</span></span><br><span class="line">               r--;<span class="comment">//只移动r，不移动l，因为nums[r]可能也等于val，导致交换后，nums[l]==val</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】6. 数组-删除排序数组中的重复项</title>
    <link href="https://m.fanruo.net/2020/02/19/%E3%80%90leetcode%E3%80%916-%E6%95%B0%E7%BB%84-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://m.fanruo.net/2020/02/19/【leetcode】6-数组-删除排序数组中的重复项/</id>
    <published>2020-02-19T15:14:08.000Z</published>
    <updated>2020-02-19T16:10:39.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你<strong>必须在原地修改输入数组并在使用 O(1)额外空间的条件</strong>下完成。</p><p><strong>示例 1</strong>:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 2</strong>:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p><p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要注意几个点：</p><ol><li>数组是有序的</li><li>删除数组中重复的元素，每个元素只保留一个</li><li>原地删除，即在传入数组的基础上删除</li><li>空间复杂度为<code>O(1)</code></li></ol><p>依据上述要求，只能操作原数组<code>nums</code>，解题思路：遍历数组，将非重复的元素前移覆盖重复元素（从重复元素的第二个开始倍覆盖）。具体算法是：</p><ol><li>设两个游标<code>k</code>和<code>i</code>,<code>k</code>为最先可以被覆盖元素的下标,<code>i</code>为数组遍历游标</li><li><code>k</code>的初始值为<code>1</code>:删除数组中重复的元素，每个元素只保留一个，因此从第二个元素开始删，即k之前的子数组各元素已经是唯一的</li><li><code>i</code>的初始值也为<code>1</code>,遍历时比较<code>nums[i]</code>是否和<code>nums[i-1]</code>,如果，如果不相等则将其移动到<code>k</code>处，并且<code>k++</code></li><li>由于<code>k</code>是最后一个可以覆盖的位置，因此<code>k</code>即新数组长度</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i<span class="number">-1</span>] != nums[i]) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你&lt;str
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】5. 数组-两数之和</title>
    <link href="https://m.fanruo.net/2020/02/19/%E3%80%90leetcode%E3%80%915-%E6%95%B0%E7%BB%84-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://m.fanruo.net/2020/02/19/【leetcode】5-数组-两数之和/</id>
    <published>2020-02-19T13:28:19.000Z</published>
    <updated>2020-02-19T13:36:33.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题比较简单，可以简单转换一下，有元素<code>nums[i]</code>， 数组<code>nums</code>是否存在<code>target - nums[i]</code>，即转换成一个查找问题：</p><ol><li>如果原地查找，不开辟额外空间的话，查找一个元素最好的情况是<code>O(log(n))</code>，这还是数组有序的情况下，显然本题数组不是有序；</li><li>可以定义一个map，查找时间复杂度是<code>O(1)</code>。<br>因此，本题，可以这么做：</li><li>遍历数组<code>nums</code>,创建map，<code>diff[nums[i]] = i</code></li><li>再次遍历<code>nums</code>,检查<code>diff[target-nums[i]]</code>是否存在，如果存在即满足需求</li></ol><p>注意，上述方法需要遍历两次数组<code>nums</code>，其实，可以只遍历一次，边遍历边检查。代码如下<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (diff.count(sub) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret.push_back(diff[sub]);</span><br><span class="line">                ret.push_back(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                diff[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;br&gt;你可以假设每
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>推荐几本redis书籍</title>
    <link href="https://m.fanruo.net/2020/02/18/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%9C%ACredis%E4%B9%A6%E7%B1%8D/"/>
    <id>https://m.fanruo.net/2020/02/18/推荐几本redis书籍/</id>
    <published>2020-02-18T05:58:50.000Z</published>
    <updated>2020-02-24T02:12:04.755Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为基于键值对的NoSQL数据库，具有高性能、丰富的数据结构、持久化、高可用、分布式等特性，同时Redis本身非常稳定，已经得到业界的广泛认可和使用。 掌握Redis已经逐步成为开发和运维人员的必备技能之一。下面分享一下几本本人看过的Redis书籍，希望对大家有所帮助。</p><h1 id="Redis开发与运维"><a href="#Redis开发与运维" class="headerlink" title="Redis开发与运维"></a>Redis开发与运维</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4.png" alt="image"><br>本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。</p><h1 id="Redis-深度历险：核心原理与应用实践"><a href="#Redis-深度历险：核心原理与应用实践" class="headerlink" title="Redis 深度历险：核心原理与应用实践"></a>Redis 深度历险：核心原理与应用实践</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9.png" alt="image"><br>Redis 是互联网技术架构在存储系统中使用得最为广泛的中间件，也是中高级后端工程师技术面试中面试官最喜欢问的工程技能之一，特别是那些优秀的互联网公司，通常要求面试者不仅仅掌握 Redis 基础用法，还要理解 Redis 内部实现的细节原理。《Redis 深度历险：核心原理与应用实践》作者老钱在使用 Redis 上积累了丰富的实战经验，希望帮助更多后端开发者更快、更深入地掌握 Redis 技能。</p><p>《Redis 深度历险：核心原理与应用实践》分为基础和应用篇、原理篇、集群篇、拓展篇、源码篇共 5 大块内容。基础和应用篇讲解对读者来说最有价值的内容，可以直接应用到实际工作中；原理篇、集群篇让开发者透过简单的技术表面看到精致的底层世界；拓展篇帮助读者拓展技术视野和夯实基础，便于进阶学习；源码篇让高阶的读者能够读懂源码，掌握核心技术实力。</p><h1 id="Redis设计与实现"><a href="#Redis设计与实现" class="headerlink" title="Redis设计与实现"></a>Redis设计与实现</h1><p><img src="http://q66nxrlmf.bkt.clouddn.com/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.png" alt="image"><br>本书全面而完整地讲解了Redis的内部机制与实现方式，对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想,图示丰富，描述清晰，并给出大量参考信息。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，更好、更高效地使用Redis。</p><p>本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制、集群三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。本书作者专门维护了 <a href="http://www.redisbook.com" target="_blank" rel="noopener">www.redisbook.com</a> 网站，提供带有详细注释的Redis源代码，以及本书相关的更新内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>三本书都是国人原创，豆瓣上都在8.5分以上，比较良心了。《Redis开发与运维》原理与实践并重的同时，更多的分析了实际生产环境中踩过的各种坑，比较接地气，毕竟大多数人只是使用而非对Redis做二次开发。《Redis设计与实现》比较详尽的介绍了Redis的实现，对有希望了解Redis底层的同学会有比较大的帮助。《Redis 深度历险：核心原理与应用实践》文风亲切，从客户端的视角去看Reids，同时对最新版本的一些关键特性做了介绍，但受限于篇幅，并没有特别深入。总之，这三本书写的通俗易懂，结合来看能够既懂原理，又能了解实践，同时对新特性也能有所收获。</p><p>好书很多，不过没看过没有发言权，不敢随意推荐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis作为基于键值对的NoSQL数据库，具有高性能、丰富的数据结构、持久化、高可用、分布式等特性，同时Redis本身非常稳定，已经得到业界的广泛认可和使用。 掌握Redis已经逐步成为开发和运维人员的必备技能之一。下面分享一下几本本人看过的Redis书籍，希望对大家有所
      
    
    </summary>
    
      <category term="Redis" scheme="https://m.fanruo.net/categories/Redis/"/>
    
      <category term="书籍推荐" scheme="https://m.fanruo.net/categories/Redis/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="Redis" scheme="https://m.fanruo.net/tags/Redis/"/>
    
      <category term="书籍推荐" scheme="https://m.fanruo.net/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】4. 数组-对角线遍历</title>
    <link href="https://m.fanruo.net/2020/02/18/%E3%80%90leetcode%E3%80%914-%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/"/>
    <id>https://m.fanruo.net/2020/02/18/【leetcode】4-数组-对角线遍历/</id>
    <published>2020-02-17T17:38:20.000Z</published>
    <updated>2020-02-18T00:12:23.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。<br>难易程度：<em>Medium</em></p><p><strong>示例</strong>:</p><p><strong>输入</strong>:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]</p><p><strong>输出</strong>:  [1,2,4,7,5,3,6,8,9]</p><p><strong>解释</strong>:<br><img src="/2020/02/18/【leetcode】4-数组-对角线遍历/diagonal_traverse.png" alt="image"></p><p><strong>说明</strong>:<br>给定矩阵中的元素总数不会超过 100000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要仔细揣摩题目，找出规律。抓住两点：</p><ol><li>题目实例，如果给出的<code>3*3</code>的矩阵不能有所收获的话，可以尝试更其他组合的矩阵，比如<code>4*3</code>等等。</li><li>题图，图的表现力更强一些，同样，如果题目种的图不能发现规律的话，可以尝试更多的矩阵。<br>经过一通分析，发现如下规律[为表述方便设某一元素的坐标为<code>(x,y)</code>]：</li><li><code>x + y</code> 为偶数是遍历方向为：<code>左下-&gt;右上，x--，y++</code>，<code>x + y</code> 为奇数是遍历方向为：<code>右上-&gt;左下,y--, x++</code></li><li>一共遍历<code>M + N - 1</code> 次，即遍历<code>[0, M+N-2]</code></li><li>第n次遍历是<code>n = x + y</code>，<code>n</code>从0开始</li><li>每次遍历的时候，<code>左下-&gt;右上</code> 若<code>x &lt; M</code>则起点为<code>(n, 0)</code>否则为<code>(M-1,n-M-1)</code>;<code>右上-&gt;左下</code>若<code>y &lt; N</code>则起点为<code>(0, n)</code>否则为<code>(n-N-1, N-1)</code></li></ol><p>具体分析如下(以示例种3*3矩阵举例)：<br>第0趟 <code>x = 0, y = 0; x + y = 0</code>，0是偶数，<code>左下-&gt;右上</code>，<code>[(0,0)],[1]</code><br>第1趟 <code>x = 0, y = 1; x + y = 1</code>，1是奇数，<code>右上-&gt;左下</code>，<code>[(0,1),(1,0)],[2,4]</code><br>第2趟 <code>x = 2, y = 0; x + y = 2</code>，2是偶数，<code>左下-&gt;右上</code>，<code>[(2,0),(1,1),(0,2)],[7,5,3]</code><br>第3趟 <code>x = 1, y = 2; x + y = 3</code>，3是奇数，<code>右上-&gt;左下</code>，<code>[(1,2),(2,1)],[6,8]</code><br>第4趟 <code>x = 2, y = 2; x + y = 4</code>，4是偶数，<code>左下-&gt;右上</code>，<code>[(2,2)],[9]</code><br>因此，对角遍历后的结果为<code>[1,2,4,7,5,3,6,8,9]</code></p><p><strong>时间复杂度</strong>：O(N*N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDiagonalOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; m + n; t++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                x = t &lt; m ? t : m - <span class="number">1</span>;</span><br><span class="line">                y = t - x;</span><br><span class="line">                <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    ret.push_back(matrix[x][y]);</span><br><span class="line">                    x--;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y = t &lt; n ? t : n - <span class="number">1</span>;</span><br><span class="line">                x = t - y;</span><br><span class="line">                <span class="keyword">while</span> (y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m) &#123;</span><br><span class="line">                    ret.push_back(matrix[x][y]);</span><br><span class="line">                    y--;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。&lt;br&gt;难易程
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】3. 数组-加一</title>
    <link href="https://m.fanruo.net/2020/02/16/%E3%80%90leetcode%E3%80%91%E6%95%B0%E7%BB%84-%E5%8A%A0%E4%B8%80/"/>
    <id>https://m.fanruo.net/2020/02/16/【leetcode】数组-加一/</id>
    <published>2020-02-16T12:16:14.000Z</published>
    <updated>2020-02-18T00:08:53.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。<br><strong>难易程度</strong>：easy<br><strong>示例 1</strong>:<br>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p><p><strong>示例 2</strong>:<br>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>此题可以理解为模拟加法。因此本题需要考虑的一点是<strong>进位</strong>问题，尤其是要考虑最高位进位。<br>看完题目，最近直接想方法是十进制加法，从最低位位开始加一，设数组digits长度为n，则从digits[n-1]开始加1，当gigits[n-1]+1&gt;10,则产出进位1，逆序遍历数组digits每个元素加上上一个元素执行加法操作之后的进位c。至此，大家可能已经发现最初的被加数1，其实可以看作c=1。直接上代码。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;<span class="comment">// 加1，看作最初的进位</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(digits);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ret.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = ret[i] + c;</span><br><span class="line">            c = tmp / <span class="number">10</span>;</span><br><span class="line">            ret[i] = tmp % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125; <span class="comment">// 提前返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            ret.insert(ret.begin(), c);<span class="comment">// vector的非尾部插入极其耗时。</span></span><br><span class="line">        &#125;<span class="comment">// 处理最高位进位</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>解法一是很常规的解法，就是模拟加法。我们仔细研究题目，会发现本题有几个特点：</p><ol><li>只加1，意味着，只有在对应的元素digits[i]是9的时候才会产生进位1</li><li>产生进位之后digits[i]对应位上只能是0<br>综上，我们只需要逆序遍历数组digits（这是数组长度为n）,如果索引i对应的元素是9，则置0继续遍历，不是9的则加1，直接返回，当一致遍历到i=0,切digits[0] = 9,才会在最高位产生进位，注意，此时索引1~(n-1)位上都是0。因此只需要将digits[0]设置为1，并且在数组尾部新增一个元素0即可。（有同学应该已经发现，只有digits数组是类似[9,9,9]（即所以元素都是9的时候）才会产生溢出）.<br>相比解法一，少了取模和除法操作，也少了vector插入操作，耗时进一步优化。</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        digits.push_back(<span class="number">0</span>);</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。&lt;br&gt;最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。&lt;br
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】数组-1. 至少是其他数字两倍的最大数</title>
    <link href="https://m.fanruo.net/2020/02/16/%E3%80%90leetcode%E3%80%91%E6%95%B0%E7%BB%84-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <id>https://m.fanruo.net/2020/02/16/【leetcode】数组-至少是其他数字两倍的最大数/</id>
    <published>2020-02-16T11:24:55.000Z</published>
    <updated>2020-02-18T00:10:12.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个给定的数组nums中，总是存在一个最大元素 。<br>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。<br>如果是，则返回最大元素的索引，否则返回-1。<br>难易程度：<em>easy</em><br><strong>示例 1</strong>:</p><p>输入: nums = [3, 6, 1, 0]<br>输出: 1<br>解释: 6是最大的整数, 对于数组中的其他整数,<br>6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1. </p><p><strong>示例 2</strong>:</p><p>输入: nums = [1, 2, 3, 4]<br>输出: -1<br>解释: 4没有超过3的两倍大, 所以我们返回 -1.</p><p><strong>提示</strong>:</p><p>nums 的长度范围在[1, 50].<br>每个 nums[i] 的整数范围在 [0, 100].</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题比较简单，只需遍历一遍数组，记录最大值max、最大值索引i以及次最大值，如果最大值大于次最大值的2倍即满足要求。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> second_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">                second_max = max;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; second_max) &#123;</span><br><span class="line">                second_max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &gt;= (second_max * <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在一个给定的数组nums中，总是存在一个最大元素 。&lt;br&gt;查找数组中的最大元素是否至少是数组中每个其他数字的两倍。&lt;br&gt;如果是，则返回最
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
