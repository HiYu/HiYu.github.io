<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-fanruo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-fanruo.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"m.fanruo.net","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CAPCAP 理论在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。  P 分区容忍性（Partition Tolerance）：当出现网络分区后，系统能够继续“履行职责” A 可用性（Availability）">
<meta property="og:type" content="article">
<meta property="og:title" content="架构设计之三——高可用架构">
<meta property="og:url" content="https://m.fanruo.net/2022/05/01/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%89%E2%80%94%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/index.html">
<meta property="og:site_name" content="凡 若">
<meta property="og:description" content="CAPCAP 理论在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。  P 分区容忍性（Partition Tolerance）：当出现网络分区后，系统能够继续“履行职责” A 可用性（Availability）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-01T14:34:55.000Z">
<meta property="article:modified_time" content="2022-05-01T15:28:49.527Z">
<meta property="article:author" content="Frank Yu">
<meta property="article:tag" content="人工智能 基础架构 读书 人文 经济 历史">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://m.fanruo.net/2022/05/01/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%89%E2%80%94%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>架构设计之三——高可用架构 | 凡 若</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">凡 若</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">初心 读书 知新 生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">21</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">48</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://m.fanruo.net/2022/05/01/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%89%E2%80%94%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Frank Yu">
      <meta itemprop="description" content="初心 读书 知新 生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡 若">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          架构设计之三——高可用架构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-01 22:34:55 / 修改时间：23:28:49" itemprop="dateCreated datePublished" datetime="2022-05-01T22:34:55+08:00">2022-05-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><p>在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。</p>
<ul>
<li>P 分区容忍性（Partition Tolerance）：当出现网络分区后，系统能够继续“履行职责”</li>
<li>A 可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）</li>
<li>C 一致性（Consistency）：对某个指定的客户端来说，读操作保证能够返回最新的写操作结果</li>
</ul>
<h2 id="CAP-特点："><a href="#CAP-特点：" class="headerlink" title="CAP 特点："></a>CAP 特点：</h2><ul>
<li>分布式系统并不一定会互联和共享数据</li>
<li>CAP 关注的是对数据的读写操作，而不是分布式系统的所有功能</li>
</ul>
<h2 id="CAP-应用"><a href="#CAP-应用" class="headerlink" title="CAP 应用"></a>CAP 应用</h2><ul>
<li>CP - Consistency&#x2F;Partition Tolerance</li>
<li>AP - Availability&#x2F;Partition Tolerance</li>
</ul>
<h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="CAP-关注的粒度是数据，而不是整个系统"><a href="#CAP-关注的粒度是数据，而不是整个系统" class="headerlink" title="CAP 关注的粒度是数据，而不是整个系统"></a>CAP 关注的粒度是数据，而不是整个系统</h3><ul>
<li>在实际设计过程中，每个系统不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择 CP，有的数据必须选择 AP。</li>
<li>。但在实际设计过程中，每个系统不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择 CP，有的数据必须选择 AP。</li>
</ul>
<h3 id="CAP-是忽略网络延迟的"><a href="#CAP-是忽略网络延迟的" class="headerlink" title="CAP 是忽略网络延迟的"></a>CAP 是忽略网络延迟的</h3><p>CAP 理论中的 C 在实践中是不可能完美实现的，在数据复制的过程中，节点 A 和节点 B 的数据并不一致。</p>
<h3 id="正常运行情况下，不存在-CP-和-AP-的选择，可以同时满足-CA"><a href="#正常运行情况下，不存在-CP-和-AP-的选择，可以同时满足-CA" class="headerlink" title="正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足 CA"></a>正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足 CA</h3><ul>
<li>CAP 理论告诉我们分布式系统只能选择 CP 或者 AP，但其实这里的前提是系统发生了“分区”现象。</li>
<li>架构设计的时候既要考虑分区发生时选择 CP 还是 AP，也要考虑分区没有发生时如何保证 CA</li>
</ul>
<h3 id="放弃并不等于什么都不做，需要为分区恢复后做准备"><a href="#放弃并不等于什么都不做，需要为分区恢复后做准备" class="headerlink" title="放弃并不等于什么都不做，需要为分区恢复后做准备"></a>放弃并不等于什么都不做，需要为分区恢复后做准备</h3><ul>
<li>最典型的就是在分区期间记录一些日志，当分区故障解决后，系统根据日志进行数据恢复，使得重新达到 CA 状态。</li>
<li>分区期间放弃 C 或者 A，并不意味着永远放弃 C 和 A，我们可以在分区期间进行一些操作，从而让分区故障解决后，系统能够重新达到 CA 的状态。</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>ACID 是数据库管理系统为了保证事务的正确性而提出来的一个理论：</p>
<ul>
<li>Atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h3 id="与CAP区别"><a href="#与CAP区别" class="headerlink" title="与CAP区别"></a>与CAP区别</h3><ul>
<li>ACID 中的 C 是指数据库的数据完整性，而 CAP 中的 C 是指分布式节点中的数据一致性</li>
<li>ACID 的应用场景是数据库事务，CAP 关注的是分布式系统数据读写</li>
<li>ACID 中的 A（Atomicity）和 CAP 中的 A（Availability）意义完全不同</li>
</ul>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>核心思想：即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。具有如下特点：</p>
<ul>
<li>基本可用（Basically Available）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li>
<li>软状态（Soft State）：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</li>
<li>最终一致性（Eventual Consistency）：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li>
</ul>
<h3 id="与CAP区别-1"><a href="#与CAP区别-1" class="headerlink" title="与CAP区别"></a>与CAP区别</h3><p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</p>
<ul>
<li>AP 方案中牺牲一致性只是指分区期间，而不是永远放弃一致性。</li>
<li>CAP 理论是忽略延时的，而实际应用中延时是无法避免的。</li>
</ul>
<h1 id="FMEA方法"><a href="#FMEA方法" class="headerlink" title="FMEA方法"></a>FMEA方法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>FMEA（Failure mode and effects analysis，故障模式与影响分析）又称为失效模式与后果分析、失效模式与效应分析、故障模式与后果分析等。<br>在架构设计领域，FMEA 的具体分析方法</p>
<ul>
<li>给出初始的架构设计图</li>
<li>假设架构中某个部件发生故障</li>
<li>分析此故障对系统功能造成的影响</li>
<li>根据分析结果，判断架构是否需要进行优化</li>
</ul>
<h2 id="FMEA-分析表"><a href="#FMEA-分析表" class="headerlink" title="FMEA 分析表"></a>FMEA 分析表</h2><ul>
<li>功能点<ul>
<li>当前的 FMEA 分析涉及的功能点，注意这里的“功能点”指的是从用户角度来看的，而不是从系统各个模块功能点划分来看的</li>
</ul>
</li>
<li>故障模式<ul>
<li>故障模式指的是系统会出现什么样的故障，包括故障点和故障形式。需要特别注意的是，这里的故障模式并不需要给出真正的故障原因，我们只需要假设出现某种故障现象即可</li>
<li>故障模式的描述要尽量精确，多使用量化描述，避免使用泛化的描述</li>
</ul>
</li>
<li>故障影响<ul>
<li>当发生故障模式中描述的故障时，功能点具体会受到什么影响</li>
<li>常见的影响有：功能点偶尔不可用、功能点完全不可用、部分用户功能点不可用、功能点响应缓慢、功能点出错等</li>
<li>故障影响也需要尽量准确描述</li>
</ul>
</li>
<li>严重程度<ul>
<li>严重程度指站在业务的角度故障的影响程度</li>
<li>一般分为“致命 &#x2F; 高 &#x2F; 中 &#x2F; 低 &#x2F; 无”五个档次</li>
<li>严重程度按照这个公式进行评估：严重程度 &#x3D; 功能点重要程度 × 故障影响范围 × 功能点受损程度</li>
</ul>
</li>
<li>故障原因<ul>
<li>不同的故障原因发生概率不相同</li>
<li>不同的故障原因检测手段不一样</li>
<li>不同的故障原因的处理措施不一样</li>
</ul>
</li>
<li>故障概率<ul>
<li>这里的概率就是指某个具体故障原因发生的概率</li>
<li>具体评估的时候需要重点关注<ul>
<li>硬件：硬件随着使用时间推移，故障概率会越来越高</li>
<li>开源系统：成熟的开源系统 bug 率低，刚发布的开源系统 bug 率相比会高一些；自己已经有使用经验的开源系统 bug 率会低，刚开始尝试使用的开源系统 bug 率会高</li>
<li>自研系统：和开源系统类似，成熟的自研系统故障概率会低，而新开发的系统故障概率会高</li>
</ul>
</li>
</ul>
</li>
<li>风险程度<ul>
<li>风险程度就是综合严重程度和故障概率来一起判断某个故障的最终等级</li>
<li>风险程度 &#x3D; 严重程度 × 故障概率。因此可能出现某个故障影响非常严重，但其概率很低，最终来看风险程度就低</li>
</ul>
</li>
<li>已有措施<ul>
<li>针对具体的故障原因，系统现在是否提供了某些措施来应对</li>
<li>主要措施<ul>
<li>检测告警：最简单的措施就是检测故障，然后告警，系统自己不针对故障进行处理，需要人工干预。</li>
<li>容错：检测到故障后，系统能够通过备份手段应对。例如，MySQL 主备机，当业务服务器检测到主机无法连接后，自动连接备机读取数据。</li>
<li>自恢复：检测到故障后，系统能够自己恢复。例如，Hadoop 检测到某台机器故障后，能够将存储在这台机器的副本重新分配到其他机器。</li>
</ul>
</li>
</ul>
</li>
<li>规避措施<ul>
<li>规避措施指为了降低故障发生概率而做的一些事情</li>
<li>主要手段<ul>
<li>技术手段：为了避免新引入的 MongoDB 丢失数据，在 MySQL 中冗余一份。</li>
<li>管理手段：为了降低磁盘坏道的概率，强制统一更换服务时间超过 2 年的磁盘。</li>
</ul>
</li>
</ul>
</li>
<li>解决措施<ul>
<li>解决措施指为了能够解决问题而做的一些事情，一般都是技术手段</li>
<li>例子<ul>
<li>为了解决密码暴力破解，增加密码重试次数限制。</li>
<li>为了解决拖库导致数据泄露，将数据库中的敏感数据加密保存。</li>
<li>为了解决非法访问，增加白名单控制。</li>
</ul>
</li>
</ul>
</li>
<li>后续规划<ul>
<li>综合前面的分析，就可以看出哪些故障我们目前还缺乏对应的措施，哪些已有措施还不够，针对这些不足的地方，再结合风险程度进行排序，给出后续的改进规划。这些规划既可以是技术手段，也可以是管理手段；可以是规避措施，也可以是解决措施。同时需要考虑资源的投入情况，优先将风险程度高的系统隐患解决。</li>
</ul>
</li>
</ul>
<h1 id="高可用存储架构"><a href="#高可用存储架构" class="headerlink" title="高可用存储架构"></a>高可用存储架构</h1><h2 id="双机架构"><a href="#双机架构" class="headerlink" title="双机架构"></a>双机架构</h2><h3 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h3><p>其整体架构比较简单，主备架构中的“备机”主要还是起到一个备份作用，并不承担实际的业务读写操作，如果要把备机改为主机，需要人工操作。</p>
<p>优点</p>
<ul>
<li>对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。</li>
<li>对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。</li>
</ul>
<p> 缺点</p>
<ul>
<li>备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。</li>
<li>故障后需要人工干预，无法自动恢复。</li>
</ul>
<p> 场景</p>
<ul>
<li>主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等</li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主机负责读写操作，从机只负责读操作，不负责写操作。</p>
<p>优点</p>
<ul>
<li>主从复制在主机故障时，读操作相关的业务可以继续运行。</li>
<li>主从复制架构的从机提供读操作，发挥了硬件的性能。</li>
</ul>
<p>缺点</p>
<ul>
<li>主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。</li>
<li>主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。</li>
<li>故障时需要人工干预。</li>
</ul>
<p>场景</p>
<p>综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。</p>
<h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><p>主主复制指的是两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操，具有如下特点：</p>
<ul>
<li>两台都是主机，不存在切换的概念。</li>
<li>客户端无须区分不同角色的主机，随便将读写操作发送给哪台主机都可以。</li>
</ul>
<p>缺点</p>
<p>如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的</p>
<ul>
<li>用户注册后生成的用户 ID，如果按照数字增长，那就不能双向复制</li>
<li>库存不能双向复制</li>
</ul>
<p>场景</p>
<p>主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。例如，用户登录产生的 session 数据（可以重新登录生成）、用户行为的日志数据（可以丢失）、论坛的草稿数据（可以丢失）等</p>
<h3 id="双机切换"><a href="#双机切换" class="headerlink" title="双机切换"></a>双机切换</h3><h4 id="设计关键"><a href="#设计关键" class="headerlink" title="设计关键"></a>设计关键</h4><p>主备复制和主从复制方案共性的问题：</p>
<ul>
<li>主机故障后，无法进行写操作。</li>
<li>如果主机无法恢复，需要人工指定新的主机角色。</li>
</ul>
<p>完善的切换方案，关键设计点</p>
<ul>
<li>主备间状态判断<ul>
<li>状态传递的渠道：是相互间互相连接，还是第三方仲裁？</li>
<li>状态检测的内容：例如机器是否掉电、进程是否存在、响应是否缓慢等。</li>
</ul>
</li>
<li>切换决策<ul>
<li>切换时机：什么情况下备机应该升级为主机？是机器掉电后备机才升级，还是主机上的进程不存在就升级，还是主机响应时间超过 2 秒就升级，还是 3 分钟内主机连续重启 3 次就升级等。</li>
<li>切换策略：原来的主机故障恢复后，要再次切换，确保原来的主机继续做主机，还是原来的主机故障恢复后自动成为新的备机？</li>
<li>自动程度：切换是完全自动的，还是半自动的？例如，系统判断当前需要切换，但需要人工做最终的确认操作</li>
</ul>
</li>
<li>数据冲突解决<ul>
<li>当原有故障的主机恢复后，新旧主机之间可能存在数据冲突</li>
</ul>
</li>
</ul>
<h4 id="常见架构"><a href="#常见架构" class="headerlink" title="常见架构"></a>常见架构</h4><ul>
<li><p>互连式</p>
<ul>
<li><p>概念</p>
<ul>
<li><p>互连式就是指主备机直接建立状态传递的渠道，</p>
</li>
<li><p>在主备复制的架构基础上，主机和备机多了一个“状态传递”的通道，这个通道就是用来传递状态信息的</p>
<ul>
<li>可以是网络连接（例如，各开一个端口），也可以是非网络连接（用串口线连接）</li>
<li>可以是主机发送状态给备机，也可以是备机到主机来获取状态信息。</li>
<li>可以和数据复制通道共用，也可以独立一条通道。</li>
<li>状态传递通道可以是一条，也可以是多条，还可以是不同类型的通道混合</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端影响</p>
<ul>
<li>为了切换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。例如虚拟 IP，主机需要绑定这个虚拟的 IP</li>
<li>客户端同时记录主备机的地址，哪个能访问就访问哪个；备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是“备机不对外提供服务”</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。</li>
<li>虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>中介式</p>
<ul>
<li><p>概念</p>
<ul>
<li>中介式指的是在主备两者之外引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>连接管理更简单：主备机无须再建立和管理多种类型的状态传递连接通道，只要连接到中介即可，实际上是降低了主备机的连接管理复杂度。</p>
</li>
<li><p>状态决策更简单：主备机的状态决策简单了，无须考虑多种类型的连接通道获取的状态信息如何决策的问题，只需要按照下面简单的算法即可完成状态决策。</p>
<ul>
<li>无论是主机还是备机，初始状态都是备机，并且只要与中介断开连接，就将自己降级为备机，因此可能出现双备机的情况。</li>
<li>主机与中介断连后，中介能够立刻告知备机，备机将自己升级为主机。</li>
<li>如果是网络中断导致主机与中介断连，主机自己会降级为备机，网络恢复后，旧的主机以新的备机身份向中介上报自己的状态。</li>
<li>主备机与中介连接都正常的情况下，按照实际的状态决定是否进行切换。例如，主机响应时间超过 3 秒就进行切换，主机降级为备机，备机升级为主机即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>虽然中介式架构在状态传递和状态决策上更加简单，但并不意味着这种优点是没有代价的，其关键代价就在于如何实现中介本身的高可用。如果中介自己宕机了，整个系统就进入了双备的状态，写操作相关的业务就不可用了</li>
</ul>
</li>
<li><p>场景</p>
<ul>
<li>MongoDB 的 Replica Set 采取的就是这种方式</li>
<li>开源方案已经有比较成熟的中介式解决方案，例如 ZooKeeper 和 Keepalived。ZooKeeper 本身已经实现了高可用集群架构，因此已经帮我们解决了中介本身的可靠性问题，在工程实践中推荐基于 ZooKeeper 搭建中介式切换架构。</li>
</ul>
</li>
</ul>
</li>
<li><p>模拟式</p>
<ul>
<li><p>概念</p>
<ul>
<li>模拟式指主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>对比一下互连式切换架构，我们可以看到，主备机之间只有数据复制通道，而没有状态传递通道，备机通过模拟的读写操作来探测主机的状态，然后根据读写操作的响应情况来进行状态决策。</li>
<li>模拟式切换与互连式切换相比，优点是实现更加简单，因为省去了状态传递通道的建立和管理工作。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>模拟式读写操作获取的状态信息只有响应信息（例如，HTTP 404，超时、响应时间超过 3 秒等），没有互连式那样多样（除了响应信息，还可以包含 CPU 负载、I&#x2F;O 负载、吞吐量、响应时间等），基于有限的状态来做状态决策，可能出现偏差。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集群-amp-分区"><a href="#集群-amp-分区" class="headerlink" title="集群&amp;分区"></a>集群&amp;分区</h2><ul>
<li><p>数据集群</p>
<ul>
<li><p>集中集群</p>
<ul>
<li><p>特点</p>
<ul>
<li>数据集中集群与主备、主从这类架构相似，我们也可以称数据集中集群为 1 主多备或者 1 主多从</li>
<li>无论是 1 主 1 从、1 主 1 备，还是 1 主多备、1 主多从，数据都只能往主机中写，而读操作可以参考主备、主从架构进行灵活多变</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li><p>主机如何将数据复制给备机主</p>
<ul>
<li>主备和主从架构中，只有一条复制通道，而数据集中集群架构中，存在多条复制通道。</li>
<li>多条复制通道首先会增大主机复制的压力，某些场景下我们需要考虑如何降低主机复制压力，或者降低主机复制给正常读写带来的压力。</li>
<li>多条复制通道可能会导致多个备机之间数据不一致，某些场景下我们需要对备机之间的数据一致性进行检查和修正。</li>
</ul>
</li>
<li><p>备机如何检测主机状态</p>
<ul>
<li>在数据集中集群架构中，多台备机都需要对主机状态进行判断，而不同的备机判断的结果可能是不同的，如何处理不同备机对主机状态的不同判断，是一个复杂的问题。</li>
</ul>
</li>
<li><p>主机故障后，如何决定新的主机</p>
<ul>
<li>在数据集中集群架构中，有多台备机都可以升级为主机，但实际上只能允许一台备机升级为主机，那么究竟选择哪一台备机作为新的主机，备机之间如何协调，这也是一个复杂的问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分散集群</p>
<ul>
<li><p>特点</p>
<ul>
<li>数据分散集群指多个服务器组成一个集群，每台服务器都会负责存储一部分数据</li>
<li>为了提升硬件利用率，每台服务器又会备份一部分数据</li>
</ul>
</li>
<li><p>复杂度：数据分散集群的复杂点在于如何将数据分配到不同的服务器上，算法需要考虑这些设计点</p>
<ul>
<li>均衡性：算法需要保证服务器上的数据分区基本是均衡的，不能存在某台服务器上的分区数量是另外一台服务器的几倍的情况</li>
<li>容错性：当出现部分服务器故障时，算法需要将原来分配给故障服务器的数据分区分配给其他服务器。</li>
<li>可伸缩性：当集群容量不够，扩充新的服务器后，算法能够自动将部分数据分区迁移到新服务器，并保证扩容后所有服务器的均衡性</li>
</ul>
</li>
</ul>
</li>
<li><p>数据分散集群和数据集中集群的不同点</p>
<ul>
<li>数据分散集群中的每台服务器都可以处理读写请求，因此不存在数据集中集群中负责写的主机那样的角色</li>
<li>数据分散集群中，必须有一个角色来负责执行数据分配算法，这个角色可以是独立的一台服务器，也可以是集群自己选举出的一台服务器</li>
<li>如果是集群服务器选举出来一台机器承担数据分区分配的职责，则这台服务器一般也会叫作主机，但我们需要知道这里的“主机”和数据集中集群中的“主机”，其职责是有差异的。</li>
<li>数据集中集群架构中，客户端只能将数据写到主机；数据分散集群架构中，客户端可以向任意服务器中读写数据</li>
</ul>
</li>
<li><p>场景</p>
<ul>
<li>数据集中集群适合数据量不大，集群机器数量不多的场景：ZooKeeper 集群，一般推荐 5 台机器左右，数据量是单台服务器就能够支撑；</li>
<li>数据分散集群，由于其良好的可伸缩性，适合业务数据量巨大、集群机器数量庞大的业务场景：Hadoop 集群、HBase 集群，大规模的集群可以达到上百台甚至上千台服务器。</li>
</ul>
</li>
</ul>
</li>
<li><p>分区</p>
<ul>
<li><p>概念</p>
<ul>
<li>数据分区指将数据按照一定的规则进行分区，不同分区分布在不同的地理位置上，每个分区存储一部分数据，通过这种方式来规避地理级别的故障所造成的巨大影响</li>
</ul>
</li>
<li><p>设计一个良好的数据分区架构，需要从多方面去考虑</p>
<ul>
<li><p>数据量：数据量的大小直接决定了分区的规则复杂度</p>
</li>
<li><p>分区规则：地理位置有近有远，因此可以得到不同的分区规则</p>
<ul>
<li>洲际分区：主要用于面向不同大洲提供服务，由于跨洲通讯的网络延迟已经大到不适合提供在线服务了，因此洲际间的数据中心可以不互通或者仅仅作为备份</li>
<li>国家分区：主要用于面向不同国家的用户提供服务，不同国家有不同语言、法律、业务等，国家间的分区一般也仅作为备份</li>
<li>城市分区：由于都在同一个国家或者地区内，网络延迟较低，业务相似，分区同时对外提供服务，可以满足业务异地多活之类的需求</li>
</ul>
</li>
<li><p>复制规则</p>
<ul>
<li><p>集中式：集中式备份指存在一个总的备份中心，所有的分区都将数据备份到备份中心</p>
<ul>
<li>设计简单，各分区之间并无直接联系，可以做到互不影响</li>
<li>扩展容易，如果要增加第四个分区，只需要将该分区的数据复制到已有备份中心即可，其他分区不受影响。</li>
<li>成本较高，需要建设一个独立的备份中心</li>
</ul>
</li>
<li><p>互备式：指每个分区备份另外一个分区的数据</p>
<ul>
<li>设计比较复杂，各个分区除了要承担业务数据存储，还需要承担备份功能，相互之间互相关联和影响。</li>
<li>扩展麻烦，新增节点需要调整已有几点</li>
<li>成本低，直接利用已有的设备。</li>
</ul>
</li>
<li><p>独立式：指每个分区自己有独立的备份中心，需要特别注意，各个分区的备份并不和原来的分区在一个地方</p>
<ul>
<li>设计简单，各分区互不影响。</li>
<li>扩展容易，新增加的分区只需要搭建自己的备份中心即可。</li>
<li>成本高，每个分区需要独立的备份中心，备份中心的场地成本是主要成本，因此独立式比集中式成本要高很多。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="高可用计算架构"><a href="#高可用计算架构" class="headerlink" title="高可用计算架构"></a>高可用计算架构</h1><ul>
<li><p>设计思想：通过增加更多服务器来达到计算高可用</p>
</li>
<li><p>设计复杂度：主要体现在任务管理方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行</p>
<ul>
<li><p>哪些服务器可以执行任务</p>
<ul>
<li>每个服务器都可以执行任务</li>
<li>只有特定服务器（通常叫“主机”）可以执行任务。当执行任务的服务器故障后，系统需要挑选新的服务器来执行任务</li>
</ul>
</li>
<li><p>任务如何重新执行</p>
<ul>
<li>对于已经分配的任务即使执行失败也不做任何处理，系统只需要保证新的任务能够分配到其他非故障服务器上执行即可</li>
<li>设计一个任务管理器来管理需要执行的计算任务，服务器执行完任务后，需要向任务管理器反馈任务执行结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行</li>
</ul>
</li>
</ul>
</li>
<li><p>架构设计</p>
<ul>
<li><p>主备</p>
<ul>
<li><p>主备架构是计算高可用最简单的架构，和存储高可用的主备复制架构类似，但是要更简单一些，因为计算高可用的主备架构无须数据复制</p>
</li>
<li><p>详细设计</p>
<ul>
<li>主机执行所有计算任务</li>
<li>当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务发送给备机，此时系统处于不可用状态</li>
<li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续将任务发送给主机。</li>
<li>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机（即原来的备机）；同时，为了继续保持主备架构，需要人工增加新的机器作为备机。</li>
</ul>
</li>
<li><p>备机</p>
<ul>
<li>冷备：备机上的程序包和配置文件都准备好，但备机上的业务系统没有启动</li>
<li>温备：备机上的业务系统已经启动，只是不对外提供服务</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点就是简单，主备机之间不需要进行交互，状态判断和切换操作由人工执行，系统实现很简单</li>
<li>缺点正好也体现在“人工操作”这点上</li>
</ul>
</li>
</ul>
</li>
<li><p>主从</p>
<ul>
<li><p>计算高可用的主从架构中的从机也是要执行任务的。任务分配器需要将任务进行分类，确定哪些任务可以发送给主机执行，哪些任务可以发送给备机执行</p>
</li>
<li><p>详细设计</p>
<ul>
<li>正常情况下，主机执行部分计算任务，，备机执行部分计算任务</li>
<li>当主机故障（例如，主机宕机）时，任务分配器不会自动将原本发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功</li>
<li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续按照原有的设计策略分配任务</li>
<li>如果主机不能够恢复，则需要人工操作，将原来的从机升级为主机（一般只是修改配置即可），增加新的机器作为从机，新的从机准备就绪后，任务分配器继续按照原有的设计策略分配任务</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：主从架构的从机也执行任务，发挥了从机的硬件性能。</li>
<li>缺点：主从架构需要将任务分类，任务分配器会复杂一些。</li>
</ul>
</li>
</ul>
</li>
<li><p>集群</p>
<ul>
<li><p>计算高可用集群包含 2 台服务器的集群，这点和存储高可用集群不太一样。存储高可用集群把双机架构和集群架构进行了区分；而在计算高可用集群架构中，2 台服务器的集群和多台服务器的集群，在设计上没有本质区别，因此不需要进行区分</p>
</li>
<li><p>对称集群</p>
<ul>
<li><p>通俗的叫法是负载均衡集群。集群中每个服务器的角色都是一样的，都可以执行所有任务</p>
</li>
<li><p>详细设计</p>
<ul>
<li>正常情况下，任务分配器采取某种策略（随机、轮询等）将计算任务分配给集群中的不同服务器</li>
<li>当集群中的某台服务器故障后，任务分配器不再将任务分配给它，而是将任务分配给其他服务器执行。</li>
</ul>
</li>
<li><p>设计关键点</p>
<ul>
<li><p>任务分配器需要选取分配策略</p>
<ul>
<li>任务分配策略比较简单，轮询和随机基本就够了</li>
</ul>
</li>
<li><p>任务分配器需要检测服务器状态</p>
<ul>
<li>状态检测稍微复杂一些，既要检测服务器的状态，例如服务器是否宕机、网络是否正常等；同时还要检测任务的执行状态，例如任务是否卡死、是否执行时间过长等。</li>
<li>常用的做法是任务分配器和服务器之间通过心跳来传递信息，包括服务器信息和任务信息，然后根据实际情况来确定状态判断条件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>非对称集群</p>
<ul>
<li><p>非对称集群中不同服务器的角色是不同的，不同角色的服务器承担不同的职责</p>
</li>
<li><p>详细设计</p>
<ul>
<li>集群会通过某种方式来区分不同服务器的角色。</li>
<li>任务分配器将不同任务发送给不同服务器。</li>
<li>当指定类型的服务器故障时，需要重新分配角色。</li>
</ul>
</li>
<li><p>设计复杂度</p>
<ul>
<li>任务分配策略更加复杂：需要将任务划分为不同类型并分配给不同角色的集群节点。</li>
<li>角色分配策略实现比较复杂：例如，可能需要使用 ZAB、Raft 这类复杂的算法来实现 Leader 的选举。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h1><ul>
<li><p>应用场景</p>
<ul>
<li><p>两个标准</p>
<ul>
<li>正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务。</li>
<li>某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务。</li>
</ul>
</li>
<li><p>代价很高</p>
<ul>
<li>系统复杂度会发生质的变化，需要设计复杂的异地多活架构。</li>
<li>成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。</li>
</ul>
</li>
</ul>
</li>
<li><p>架构模式</p>
<ul>
<li><p>同城异区</p>
<ul>
<li>结合复杂度、成本、故障发生概率来综合考虑，同城异区是应对机房级别故障的最优架构。</li>
<li>关键在于搭建高速网络将两个机房连接起来，达到近似一个本地机房的效果。架构设计上可以将两个机房当作本地机房来设计，无须额外考虑。</li>
</ul>
</li>
<li><p>跨城异地</p>
<ul>
<li>跨城异地距离较远带来的网络传输延迟问题，给异地多活架构设计带来了复杂性，如果要做到真正意义上的多活，业务系统需要考虑部署在不同地点的两个机房，在数据短时间不一致的情况下，还能够正常提供业务。</li>
<li>关键在于数据不一致的情况下，业务不受影响或者影响很小，这从逻辑的角度上来说其实是矛盾的，架构设计的主要目的就是为了解决这个矛盾。</li>
<li>这就引入了一个看似矛盾的地方：数据不一致业务肯定不会正常，但跨城异地肯定会导致数据不一致。</li>
<li>如果是强一致性要求的数据，例如银行存款余额、支付宝余额等，这类数据实际上是无法做到跨城异地多活的。</li>
</ul>
</li>
<li><p>跨国异地</p>
<ul>
<li>为不同地区用户提供服务</li>
<li>只读类业务做多活</li>
</ul>
</li>
</ul>
</li>
<li><p>技巧</p>
<ul>
<li><p>保证核心业务的异地多活</p>
</li>
<li><p>保证核心数据最终一致性</p>
<ul>
<li>尽量减少异地多活机房的距离，搭建高速网络</li>
<li>尽量减少数据同步，只同步核心业务相关的数据</li>
<li>保证最终一致性，不保证实时一致性</li>
</ul>
</li>
<li><p>采用多种手段同步数据</p>
<ul>
<li>消息队列方式:对于账号数据，由于账号只会创建，不会修改和删除（假设我们不提供删除功能），我们可以将账号数据通过消息队列同步到其他业务中心。</li>
<li>二次读取方式:第一次读取本地，本地失败后第二次读取对端</li>
<li>存储系统同步方式:对于密码数据，由于用户改密码频率较低，而且用户不可能在 1 秒内连续改多次密码，所以通过数据库的同步机制将数据复制到其他业务中心即可，用户信息数据和密码类似。</li>
<li>回源读取方式:当用户在 A 中心登录后，然后又在 B 中心登录，B 中心拿到用户上传的 session id 后，根据路由判断 session 属于 A 中心，直接去 A 中心请求 session 数据即可；反之亦然，A 中心也可以到 B 中心去获取 session 数据。</li>
<li>重新生成数据方式:对于“回源读取”场景，如果异常情况下，A 中心宕机了，B 中心请求 session 数据失败，此时就只能登录失败，让用户重新在 B 中心登录，生成新的 session 数据。</li>
</ul>
</li>
<li><p>只保证绝大部分用户的异地多活</p>
</li>
<li><p>核心思想：采用多种手段，保证绝大部分用户的核心业务异地多活！</p>
</li>
</ul>
</li>
<li><p>四步走</p>
<ul>
<li><p>业务分级</p>
<ul>
<li><p>按照一定的标准将业务进行分级，挑选出核心的业务，只为核心业务设计异地多活，降低方案整体复杂度和实现成本。</p>
</li>
<li><p>常见的分级标准</p>
<ul>
<li>访问量大的业务</li>
<li>核心业务</li>
<li>产生大量收入的业务</li>
</ul>
</li>
</ul>
</li>
<li><p>数据分类</p>
<ul>
<li><p>挑选出核心业务后，需要对核心业务相关的数据进一步分析，目的在于识别所有的数据及数据特征，这些数据特征会影响后面的方案设计。</p>
</li>
<li><p>常见的数据特征分析维度</p>
<ul>
<li><p>数据量：这里的数据量包括总的数据量和新增、修改、删除的量。对异地多活架构来说，新增、修改、删除的数据就是可能要同步的数据，数据量越大，同步延迟的几率越高，同步方案需要考虑相应的解决方案。</p>
</li>
<li><p>唯一性：唯一性指数据是否要求多个异地机房产生的同类数据必须保证唯一。</p>
<ul>
<li>数据的唯一性影响业务的多活设计，如果数据不需要唯一，那就说明两个地方都产生同类数据是可能的；</li>
<li>如果数据要求必须唯一，要么只能一个中心点产生数据，要么需要设计一个数据唯一生成的算法。</li>
</ul>
</li>
<li><p>实时性：实时性要求越高，对同步的要求越高，方案越复杂。</p>
</li>
<li><p>可丢失性：可丢失性指数据是否可以丢失。</p>
</li>
<li><p>可恢复性：可恢复性指数据丢失后，是否可以通过某种手段进行恢复，如果数据可以恢复，至少说明对业务的影响不会那么大，这样可以相应地降低异地多活架构设计的复杂度。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据同步</p>
<ul>
<li><p>常见的数据同步方案</p>
<ul>
<li><p>存储系统同步</p>
<ul>
<li>优点：使用简单，因为几乎主流的存储系统都会有自己的同步方案</li>
<li>缺点：这类同步方案都是通用的，无法针对业务数据特点做定制化的控制。</li>
</ul>
</li>
<li><p>消息队列同步</p>
<ul>
<li>消息队列同步适合无事务性或者无时序性要求的数据。对于新注册的用户账号，我们可以采用消息队列同步了；而对于用户密码，就不能采用消息队列同步了。</li>
</ul>
</li>
<li><p>重复生成</p>
<ul>
<li>数据不同步到异地机房，每个机房都可以生成数据，这个方案适合于可以重复生成的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异常处理</p>
<ul>
<li><p>无论数据同步方案如何设计，一旦出现极端异常的情况，总是会有部分数据出现异常的</p>
<ul>
<li>同步延迟</li>
<li>数据丢失</li>
<li>数据不一致</li>
</ul>
</li>
<li><p>异常处理主要目的</p>
<ul>
<li>问题发生时，避免少量数据异常导致整体业务不可用。</li>
<li>问题恢复后，将异常的数据进行修正。</li>
<li>对用户进行安抚，弥补用户损失。</li>
</ul>
</li>
<li><p>常见的异常处理措施</p>
<ul>
<li><p>多通道同步</p>
<ul>
<li><p>采取多种方式来进行数据同步，其中某条通道故障的情况下，系统可以通过其他方式来进行同步，这种方式可以应对同步通道处故障的情况</p>
</li>
<li><p>方案关键点</p>
<ul>
<li>一般情况下，采取两通道即可，采取更多通道理论上能够降低风险，但付出的成本也会增加很多。</li>
<li>数据库同步通道和消息队列同步通道不能采用相同的网络连接，否则一旦网络故障，两个通道都同时故障；可以一个走公网连接，一个走内网连接。</li>
<li>需要数据是可以重复覆盖的，即无论哪个通道先到哪个通道后到，最终结果是一样的。例如，新建账号数据就符合这个标准，而密码数据则不符合这个标准。</li>
</ul>
</li>
</ul>
</li>
<li><p>同步和访问结合</p>
<ul>
<li><p>访问指异地机房通过系统的接口来进行数据访问</p>
</li>
<li><p>设计关键点</p>
<ul>
<li>接口访问通道和数据库同步通道不能采用相同的网络连接，不能让数据库同步和接口访问都走同一条网络通道，可以采用接口访问走公网连接，数据库同步走内网连接这种方式。</li>
<li>数据有路由规则，可以根据数据来推断应该访问哪个机房的接口来读取数据。</li>
<li>由于有同步通道，优先读取本地数据，本地数据无法读取到再通过接口去访问，这样可以大大降低跨机房的异地接口访问数量，适合于实时性要求非常高的数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>日志记录</p>
<ul>
<li><p>主要用于用户故障恢复后对数据进行恢复，其主要方式是每个关键操作前后都记录相关一条日志，然后将日志保存在一个独立的地方，当故障恢复后，拿出日志跟数据进行对比，对数据进行修复。</p>
</li>
<li><p>常见日志保存方式</p>
<ul>
<li>服务器上保存日志，数据库中保存数据，这种方式可以应对单台数据库服务器故障或者宕机的情况。</li>
<li>本地独立系统保存日志，这种方式可以应对某业务服务器和数据库同时宕机的情况。</li>
<li>日志异地保存，这种方式可以应对机房宕机的情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>用户补偿</p>
<ul>
<li>无论多么完美的方案，故障的场景下总是可能有一小部分用户业务上出问题，系统无法弥补这部分用户的损失。</li>
<li>可以采用人工的方式对用户进行补偿，弥补用户损失，培养用户的忠诚度。简单来说，系统的方案是为了保证 99.99% 的用户在故障的场景下业务不受影响，人工的补偿是为了弥补 0.01% 的用户的损失。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="接口故障处理"><a href="#接口故障处理" class="headerlink" title="接口故障处理"></a>接口故障处理</h1><ul>
<li><p>典型表现</p>
<ul>
<li>系统并没有宕机、网络也没有中断，但业务却出现问题了</li>
<li>如业务响应缓慢、大量访问超时和大量访问出现异常</li>
</ul>
</li>
<li><p>主要原因</p>
<ul>
<li><p>在于系统压力太大、负载太高，导致无法快速处理业务请求，由此引发更多的后续问题</p>
</li>
<li><p>原因分类</p>
<ul>
<li>内部原因：包括程序 bug 导致死循环，某个接口导致数据库慢查询，程序逻辑不完善导致耗尽内存等。</li>
<li>外部原因：包括黑客攻击，促销或者抢购引入了超出平时几倍甚至几十倍的用户，第三方系统大量请求，第三方系统响应缓慢等。</li>
</ul>
</li>
</ul>
</li>
<li><p>常见情况</p>
<ul>
<li>最常见的情况就是，数据库慢查询将数据库的服务器资源耗尽，导致读写超时，业务读写数据库时要么无法连接数据库、要么超时，最终用户看到的现象就是访问很慢，一会儿访问抛出异常，一会儿访问又是正常结果</li>
</ul>
</li>
<li><p>解决接口级故障的核心思想</p>
<ul>
<li>优先保证核心业务</li>
<li>优先保证绝大部分用户</li>
</ul>
</li>
<li><p>应对方法</p>
<ul>
<li><p>降级</p>
<ul>
<li><p>定义：降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。</p>
</li>
<li><p>核心思想：丢车保帅，优先保证核心业务</p>
</li>
<li><p>常见的实现降级的方式</p>
<ul>
<li><p>系统后门降级：就是系统预留了后门用于降级操作</p>
<ul>
<li>优点：系统后门降级的方式实现成本低</li>
<li>缺点：如果服务器数量多，需要一台一台去操作，效率比较低，这在故障处理争分夺秒的场景下是比较浪费时间的。</li>
</ul>
</li>
<li><p>独立降级系统：将降级操作独立到一个单独的系统中，实现复杂的权限管理、批量操作等功能。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>熔断</p>
<ul>
<li><p>定义：熔断是指按照规则停掉外部接口的访问，防止某些外部接口故障导致自己的系统处理能力急剧下降或者出故障。</p>
</li>
<li><p>与降级区别</p>
<ul>
<li>降级的目的是应对系统自身的故障</li>
<li>熔断的目的是应对依赖的外部系统故障的情况</li>
</ul>
</li>
<li><p>实现熔断机制键点</p>
<ul>
<li>一是需要有一个统一的 API 调用层，由 API 调用层来进行采样或者统计。如果接口调用散落在代码各处，就没法进行统一处理了。</li>
<li>二是阈值的设计，例如 1 分钟内 30% 的请求响应时间超过 1 秒就熔断，这个策略中的“1 分钟”“30%”“1 秒”都对最终的熔断效果有影响。实践中，一般都是先根据分析确定阈值，然后上线观察效果，再进行调优。</li>
</ul>
</li>
</ul>
</li>
<li><p>限流</p>
<ul>
<li><p>定义：限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。</p>
</li>
<li><p>与降级区别</p>
<ul>
<li>降级是从系统功能优先级的角度考虑如何应对故障</li>
<li>限流则是从用户访问压力的角度来考虑如何应对故障</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>基于请求限流</p>
<ul>
<li><p>分类</p>
<ul>
<li>限制总量，也就是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量</li>
<li>限制时间量，也就是限制一段时间内某个指标的上限，例如 1 分钟内只允许 10000 个用户访问；每秒请求峰值最高为 10 万。</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>无论是限制总量还是限制时间量，共同的特点都是实现简单</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>比较难以找到合适的阈值</li>
<li>即使找到了合适的阈值，基于请求限流还面临硬件相关的问题。例如一台 32 核的机器和 64 核的机器处理能力差别很大</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>为了找到合理的阈值，通常情况下可以采用性能压测来确定阈值，但性能压测也存在覆盖场景有限的问题，可能出现某个性能压测没有覆盖的功能导致系统压力很大</li>
<li>逐步优化：先设定一个阈值然后上线观察运行情况，发现不合理就调整阈值。</li>
</ul>
</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>根据阈值来限制访问量的方式更多的适应于业务功能比较简单的系统，例如负载均衡系统、网关系统、抢购系统等。</li>
</ul>
</li>
</ul>
</li>
<li><p>基于资源限流</p>
<ul>
<li><p>概念</p>
<ul>
<li>基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，也就是找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源包括连接数、文件句柄、线程数和请求队列等。</li>
<li>基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力</li>
</ul>
</li>
<li><p>难点</p>
<ul>
<li>如何确定关键资源</li>
<li>如何确定关键资源的阈值</li>
<li>解决方案：逐步调优的过程：设计的时候先根据推断选择某个关键资源和阈值，然后测试验证，再上线观察，如果发现不合理，再进行优化。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li><p>时间窗：限制一定时间窗口内的请求量或者资源消耗量</p>
<ul>
<li><p>固定时间窗</p>
<ul>
<li><p>定义：统计固定时间周期内的请求量或者资源消耗量，超过限额就会启动限流</p>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：实现简单</li>
<li>缺点：存在临界点问题</li>
</ul>
</li>
</ul>
</li>
<li><p>滑动时间窗</p>
<ul>
<li><p>定义：两个统计周期部分重叠，从而避免短时间内的两个统计点分属不同的时间窗的情况</p>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：解决了临界点问题</li>
<li>缺点：实现复杂些</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>桶算法：用一个虚拟的“桶”来临时存储一些东西，来起到控制速率的效果</p>
<ul>
<li><p>漏桶</p>
<ul>
<li><p>定义：将请求放入“桶”（消息队列等），业务处理单元（线程、进程和应用等）从桶里拿请求处理，桶满则丢弃新的请求</p>
</li>
<li><p>设计关键点</p>
<ul>
<li>流入速率不固定：可能瞬间流入非常多的请求，例如 0 点签到、整点秒杀。</li>
<li>匀速 (极速) 流出：这是理解漏桶算法的关键，也就是说即使大量请求进入了漏桶，但是从漏桶流出的速度是匀速的，速度的最大值就是系统的极限处理速度。需要注意的是：如果漏桶没有堆积，那么流出速度就等于流入速度，这个时候流出速度就不是匀速的。这样就保证了系统在收到海量请求的时候不被压垮，这是第一层的保护措施。</li>
<li>桶满则丢弃请求：这是第二层保护措施，也就是说漏桶不是无限容量，而是有限容量，例如漏桶最多存储 100 万个请求，桶满了则直接丢弃后面的请求。</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>实现简单</li>
<li>提供双层保护措施</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>突发大量流量时丢弃的请求较少，因为漏桶本身有缓存请求的作用。</li>
<li>桶大小动态调整比较困难（例如 Java BlockingQueue），需要不断的尝试才能找到符合业务需求的最佳桶大小。</li>
<li>无法精确控制流出速度，也就是业务的处理速度。</li>
</ul>
</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>主要适用于瞬时高并发流量的场景（例如刚才提到的 0 点签到、整点秒杀等）。</li>
</ul>
</li>
</ul>
</li>
<li><p>令牌桶</p>
<ul>
<li><p>定义：令牌桶算法和漏桶算法的不同之处在于，桶中放入的不是请求，而是“令牌”，这个令牌就是业务处理前需要拿到的“许可证”。也就是说，当系统收到一个请求时，先要到令牌桶里面拿“令牌”，拿到令牌才能进一步处理，拿不到就要丢弃请求。</p>
</li>
<li><p>设计关键点</p>
<ul>
<li>有一个处理单元往桶里面放令牌，放的速率是可以控制的。</li>
<li>桶里面可以累积一定数量的令牌，当突发流量过来的时候，因为桶里面有累积的令牌，此时的业务处理速度会超过令牌放入的速度。</li>
<li>如果令牌不足，即使系统有能力处理，也会丢弃请求。</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>可以动态调整处理速率，实现更加灵活。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>突发大量流量的时候可能丢弃很多请求，因为令牌桶不能累积太多令牌。</li>
<li>实现相对复杂。</li>
</ul>
</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>一种是需要控制访问第三方服务的速度，防止把下游压垮，例如支付宝需要控制访问银行接口的速率；</li>
<li>一种是需要控制自己的处理速度，防止过载，例如压测结果显示系统最大处理 TPS 是 100，那么就可以用令牌桶来限制最大的处理速度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>排队</p>
<ul>
<li><p>定义：排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间</p>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li>排队虽然没有直接拒绝用户，</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>用户等了很长时间后进入系统，体验并不一定比限流好</li>
<li>由于排队需要临时缓存大量的业务请求，单个系统内部无法缓存这么多数据，一般情况下，排队需要用独立的系统去实现，例如使用 Kafka 这类消息队列来缓存用户请求。</li>
</ul>
</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>秒杀活动等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Frank Yu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://m.fanruo.net/2022/05/01/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%89%E2%80%94%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/" title="架构设计之三——高可用架构">https://m.fanruo.net/2022/05/01/架构设计之三——高可用架构/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/30/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%BA%8C%E2%80%94%E2%80%94%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84/" rel="prev" title="架构设计之二——高性能架构">
      <i class="fa fa-chevron-left"></i> 架构设计之二——高性能架构
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CAP"><span class="nav-number">1.</span> <span class="nav-text">CAP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAP-%E7%90%86%E8%AE%BA"><span class="nav-number">1.1.</span> <span class="nav-text">CAP 理论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAP-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">CAP 特点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAP-%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">CAP 应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="nav-number">1.4.</span> <span class="nav-text">一些细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAP-%E5%85%B3%E6%B3%A8%E7%9A%84%E7%B2%92%E5%BA%A6%E6%98%AF%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">CAP 关注的粒度是数据，而不是整个系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAP-%E6%98%AF%E5%BF%BD%E7%95%A5%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E7%9A%84"><span class="nav-number">1.4.2.</span> <span class="nav-text">CAP 是忽略网络延迟的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8-CP-%E5%92%8C-AP-%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E6%BB%A1%E8%B6%B3-CA"><span class="nav-number">1.4.3.</span> <span class="nav-text">正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足 CA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BE%E5%BC%83%E5%B9%B6%E4%B8%8D%E7%AD%89%E4%BA%8E%E4%BB%80%E4%B9%88%E9%83%BD%E4%B8%8D%E5%81%9A%EF%BC%8C%E9%9C%80%E8%A6%81%E4%B8%BA%E5%88%86%E5%8C%BA%E6%81%A2%E5%A4%8D%E5%90%8E%E5%81%9A%E5%87%86%E5%A4%87"><span class="nav-number">1.4.4.</span> <span class="nav-text">放弃并不等于什么都不做，需要为分区恢复后做准备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID"><span class="nav-number">1.5.</span> <span class="nav-text">ACID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8ECAP%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.1.</span> <span class="nav-text">与CAP区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BASE"><span class="nav-number">1.6.</span> <span class="nav-text">BASE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8ECAP%E5%8C%BA%E5%88%AB-1"><span class="nav-number">1.6.1.</span> <span class="nav-text">与CAP区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FMEA%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">FMEA方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FMEA-%E5%88%86%E6%9E%90%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">FMEA 分析表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">高可用存储架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%9C%BA%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">双机架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.1.</span> <span class="nav-text">主备复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.2.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.3.</span> <span class="nav-text">主主复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%9C%BA%E5%88%87%E6%8D%A2"><span class="nav-number">3.1.4.</span> <span class="nav-text">双机切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">设计关键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">常见架构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4-amp-%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.</span> <span class="nav-text">集群&amp;分区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">高可用计算架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB"><span class="nav-number">5.</span> <span class="nav-text">异地多活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">接口故障处理</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Frank Yu</p>
  <div class="site-description" itemprop="description">初心 读书 知新 生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/HiYu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HiYu" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank">E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>



      </div>
     <div class="wechat_channel">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src ="/images/wechat.jpg">
         <span>公众号</span>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frank Yu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">119k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
